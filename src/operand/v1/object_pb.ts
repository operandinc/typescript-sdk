// @generated by protoc-gen-es v0.1.1 with parameter "target=ts+js"
// @generated from file operand/v1/object.proto (package operand.v1, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, Timestamp} from "@bufbuild/protobuf";

/**
 * @generated from enum operand.v1.ObjectType
 */
export enum ObjectType {
  /**
   * @generated from enum value: OBJECT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OBJECT_TYPE_COLLECTION = 1;
   */
  COLLECTION = 1,

  /**
   * @generated from enum value: OBJECT_TYPE_TEXT = 2;
   */
  TEXT = 2,

  /**
   * @generated from enum value: OBJECT_TYPE_HTML = 3;
   */
  HTML = 3,

  /**
   * @generated from enum value: OBJECT_TYPE_RSS = 4;
   */
  RSS = 4,

  /**
   * @generated from enum value: OBJECT_TYPE_AUDIO = 5;
   */
  AUDIO = 5,

  /**
   * @generated from enum value: OBJECT_TYPE_PODCAST = 6;
   */
  PODCAST = 6,

  /**
   * @generated from enum value: OBJECT_TYPE_SITEMAP = 7;
   */
  SITEMAP = 7,

  /**
   * @generated from enum value: OBJECT_TYPE_PDF = 8;
   */
  PDF = 8,

  /**
   * @generated from enum value: OBJECT_TYPE_EPUB = 9;
   */
  EPUB = 9,

  /**
   * @generated from enum value: OBJECT_TYPE_YOUTUBE = 10;
   */
  YOUTUBE = 10,

  /**
   * @generated from enum value: OBJECT_TYPE_MARKDOWN = 11;
   */
  MARKDOWN = 11,

  /**
   * @generated from enum value: OBJECT_TYPE_SLACK = 12;
   */
  SLACK = 12,

  /**
   * @generated from enum value: OBJECT_TYPE_GITHUB_REPOSITORY = 13;
   */
  GITHUB_REPOSITORY = 13,

  /**
   * @generated from enum value: OBJECT_TYPE_SOURCE_CODE = 14;
   */
  SOURCE_CODE = 14,

  /**
   * @generated from enum value: OBJECT_TYPE_NOTION = 15;
   */
  NOTION = 15,

  /**
   * @generated from enum value: OBJECT_TYPE_DISCORD = 16;
   */
  DISCORD = 16,

  /**
   * @generated from enum value: OBJECT_TYPE_LINEAR = 17;
   */
  LINEAR = 17,
}
// Retrieve enum metadata with: proto3.getEnumType(ObjectType)
proto3.util.setEnumType(ObjectType, "operand.v1.ObjectType", [
  { no: 0, name: "OBJECT_TYPE_UNSPECIFIED" },
  { no: 1, name: "OBJECT_TYPE_COLLECTION" },
  { no: 2, name: "OBJECT_TYPE_TEXT" },
  { no: 3, name: "OBJECT_TYPE_HTML" },
  { no: 4, name: "OBJECT_TYPE_RSS" },
  { no: 5, name: "OBJECT_TYPE_AUDIO" },
  { no: 6, name: "OBJECT_TYPE_PODCAST" },
  { no: 7, name: "OBJECT_TYPE_SITEMAP" },
  { no: 8, name: "OBJECT_TYPE_PDF" },
  { no: 9, name: "OBJECT_TYPE_EPUB" },
  { no: 10, name: "OBJECT_TYPE_YOUTUBE" },
  { no: 11, name: "OBJECT_TYPE_MARKDOWN" },
  { no: 12, name: "OBJECT_TYPE_SLACK" },
  { no: 13, name: "OBJECT_TYPE_GITHUB_REPOSITORY" },
  { no: 14, name: "OBJECT_TYPE_SOURCE_CODE" },
  { no: 15, name: "OBJECT_TYPE_NOTION" },
  { no: 16, name: "OBJECT_TYPE_DISCORD" },
  { no: 17, name: "OBJECT_TYPE_LINEAR" },
]);

/**
 * @generated from enum operand.v1.AudioFileExt
 */
export enum AudioFileExt {
  /**
   * @generated from enum value: AUDIO_FILE_EXT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: AUDIO_FILE_EXT_MP3 = 1;
   */
  MP3 = 1,

  /**
   * @generated from enum value: AUDIO_FILE_EXT_OGG = 2;
   */
  OGG = 2,

  /**
   * @generated from enum value: AUDIO_FILE_EXT_FLAC = 3;
   */
  FLAC = 3,

  /**
   * @generated from enum value: AUDIO_FILE_EXT_WAV = 4;
   */
  WAV = 4,

  /**
   * @generated from enum value: AUDIO_FILE_EXT_MP4 = 5;
   */
  MP4 = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(AudioFileExt)
proto3.util.setEnumType(AudioFileExt, "operand.v1.AudioFileExt", [
  { no: 0, name: "AUDIO_FILE_EXT_UNSPECIFIED" },
  { no: 1, name: "AUDIO_FILE_EXT_MP3" },
  { no: 2, name: "AUDIO_FILE_EXT_OGG" },
  { no: 3, name: "AUDIO_FILE_EXT_FLAC" },
  { no: 4, name: "AUDIO_FILE_EXT_WAV" },
  { no: 5, name: "AUDIO_FILE_EXT_MP4" },
]);

/**
 * @generated from enum operand.v1.ProgrammingLanguage
 */
export enum ProgrammingLanguage {
  /**
   * @generated from enum value: PROGRAMMING_LANGUAGE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROGRAMMING_LANGUAGE_GO = 1;
   */
  GO = 1,

  /**
   * @generated from enum value: PROGRAMMING_LANGUAGE_PYTHON = 2;
   */
  PYTHON = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ProgrammingLanguage)
proto3.util.setEnumType(ProgrammingLanguage, "operand.v1.ProgrammingLanguage", [
  { no: 0, name: "PROGRAMMING_LANGUAGE_UNSPECIFIED" },
  { no: 1, name: "PROGRAMMING_LANGUAGE_GO" },
  { no: 2, name: "PROGRAMMING_LANGUAGE_PYTHON" },
]);

/**
 * @generated from enum operand.v1.ObjectStatus
 */
export enum ObjectStatus {
  /**
   * @generated from enum value: OBJECT_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OBJECT_STATUS_QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: OBJECT_STATUS_INDEXING = 2;
   */
  INDEXING = 2,

  /**
   * @generated from enum value: OBJECT_STATUS_READY = 3;
   */
  READY = 3,

  /**
   * @generated from enum value: OBJECT_STATUS_ERROR = 4;
   */
  ERROR = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ObjectStatus)
proto3.util.setEnumType(ObjectStatus, "operand.v1.ObjectStatus", [
  { no: 0, name: "OBJECT_STATUS_UNSPECIFIED" },
  { no: 1, name: "OBJECT_STATUS_QUEUED" },
  { no: 2, name: "OBJECT_STATUS_INDEXING" },
  { no: 3, name: "OBJECT_STATUS_READY" },
  { no: 4, name: "OBJECT_STATUS_ERROR" },
]);

/**
 * @generated from message operand.v1.ObjectMetadata
 */
export class ObjectMetadata extends Message<ObjectMetadata> {
  /**
   * @generated from oneof operand.v1.ObjectMetadata.value
   */
  value: {
    /**
     * @generated from field: operand.v1.CollectionMetadata collection = 1;
     */
    value: CollectionMetadata;
    case: "collection";
  } | {
    /**
     * @generated from field: operand.v1.TextMetadata text = 2;
     */
    value: TextMetadata;
    case: "text";
  } | {
    /**
     * @generated from field: operand.v1.HTMLMetadata html = 3;
     */
    value: HTMLMetadata;
    case: "html";
  } | {
    /**
     * @generated from field: operand.v1.RSSMetadata rss = 4;
     */
    value: RSSMetadata;
    case: "rss";
  } | {
    /**
     * @generated from field: operand.v1.AudioMetadata audio = 5;
     */
    value: AudioMetadata;
    case: "audio";
  } | {
    /**
     * @generated from field: operand.v1.PodcastMetadata podcast = 6;
     */
    value: PodcastMetadata;
    case: "podcast";
  } | {
    /**
     * @generated from field: operand.v1.SitemapMetadata sitemap = 7;
     */
    value: SitemapMetadata;
    case: "sitemap";
  } | {
    /**
     * @generated from field: operand.v1.PDFMetadata pdf = 8;
     */
    value: PDFMetadata;
    case: "pdf";
  } | {
    /**
     * @generated from field: operand.v1.EPUBMetadata epub = 9;
     */
    value: EPUBMetadata;
    case: "epub";
  } | {
    /**
     * @generated from field: operand.v1.YouTubeMetadata youtube = 10;
     */
    value: YouTubeMetadata;
    case: "youtube";
  } | {
    /**
     * @generated from field: operand.v1.MarkdownMetadata markdown = 11;
     */
    value: MarkdownMetadata;
    case: "markdown";
  } | {
    /**
     * @generated from field: operand.v1.SlackMetadata slack = 12;
     */
    value: SlackMetadata;
    case: "slack";
  } | {
    /**
     * @generated from field: operand.v1.GithubRepositoryMetadata github = 13;
     */
    value: GithubRepositoryMetadata;
    case: "github";
  } | {
    /**
     * @generated from field: operand.v1.SourceCodeMetadata source_code = 14;
     */
    value: SourceCodeMetadata;
    case: "sourceCode";
  } | {
    /**
     * @generated from field: operand.v1.NotionMetadata notion = 15;
     */
    value: NotionMetadata;
    case: "notion";
  } | {
    /**
     * @generated from field: operand.v1.DiscordMetadata discord = 16;
     */
    value: DiscordMetadata;
    case: "discord";
  } | {
    /**
     * @generated from field: operand.v1.LinearMetadata linear = 17;
     */
    value: LinearMetadata;
    case: "linear";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.ObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection", kind: "message", T: CollectionMetadata, oneof: "value" },
    { no: 2, name: "text", kind: "message", T: TextMetadata, oneof: "value" },
    { no: 3, name: "html", kind: "message", T: HTMLMetadata, oneof: "value" },
    { no: 4, name: "rss", kind: "message", T: RSSMetadata, oneof: "value" },
    { no: 5, name: "audio", kind: "message", T: AudioMetadata, oneof: "value" },
    { no: 6, name: "podcast", kind: "message", T: PodcastMetadata, oneof: "value" },
    { no: 7, name: "sitemap", kind: "message", T: SitemapMetadata, oneof: "value" },
    { no: 8, name: "pdf", kind: "message", T: PDFMetadata, oneof: "value" },
    { no: 9, name: "epub", kind: "message", T: EPUBMetadata, oneof: "value" },
    { no: 10, name: "youtube", kind: "message", T: YouTubeMetadata, oneof: "value" },
    { no: 11, name: "markdown", kind: "message", T: MarkdownMetadata, oneof: "value" },
    { no: 12, name: "slack", kind: "message", T: SlackMetadata, oneof: "value" },
    { no: 13, name: "github", kind: "message", T: GithubRepositoryMetadata, oneof: "value" },
    { no: 14, name: "source_code", kind: "message", T: SourceCodeMetadata, oneof: "value" },
    { no: 15, name: "notion", kind: "message", T: NotionMetadata, oneof: "value" },
    { no: 16, name: "discord", kind: "message", T: DiscordMetadata, oneof: "value" },
    { no: 17, name: "linear", kind: "message", T: LinearMetadata, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectMetadata | PlainMessage<ObjectMetadata> | undefined, b: ObjectMetadata | PlainMessage<ObjectMetadata> | undefined): boolean {
    return proto3.util.equals(ObjectMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.CollectionMetadata
 */
export class CollectionMetadata extends Message<CollectionMetadata> {
  constructor(data?: PartialMessage<CollectionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.CollectionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionMetadata {
    return new CollectionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionMetadata {
    return new CollectionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionMetadata {
    return new CollectionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionMetadata | PlainMessage<CollectionMetadata> | undefined, b: CollectionMetadata | PlainMessage<CollectionMetadata> | undefined): boolean {
    return proto3.util.equals(CollectionMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.TextMetadata
 */
export class TextMetadata extends Message<TextMetadata> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<TextMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.TextMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextMetadata {
    return new TextMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextMetadata {
    return new TextMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextMetadata {
    return new TextMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: TextMetadata | PlainMessage<TextMetadata> | undefined, b: TextMetadata | PlainMessage<TextMetadata> | undefined): boolean {
    return proto3.util.equals(TextMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.HTMLMetadata
 */
export class HTMLMetadata extends Message<HTMLMetadata> {
  /**
   * @generated from field: optional string html = 1;
   */
  html?: string;

  constructor(data?: PartialMessage<HTMLMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.HTMLMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "html", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTMLMetadata {
    return new HTMLMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTMLMetadata {
    return new HTMLMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTMLMetadata {
    return new HTMLMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: HTMLMetadata | PlainMessage<HTMLMetadata> | undefined, b: HTMLMetadata | PlainMessage<HTMLMetadata> | undefined): boolean {
    return proto3.util.equals(HTMLMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.MarkdownMetadata
 */
export class MarkdownMetadata extends Message<MarkdownMetadata> {
  /**
   * @generated from field: optional string markdown = 1;
   */
  markdown?: string;

  constructor(data?: PartialMessage<MarkdownMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.MarkdownMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "markdown", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarkdownMetadata {
    return new MarkdownMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarkdownMetadata {
    return new MarkdownMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarkdownMetadata {
    return new MarkdownMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MarkdownMetadata | PlainMessage<MarkdownMetadata> | undefined, b: MarkdownMetadata | PlainMessage<MarkdownMetadata> | undefined): boolean {
    return proto3.util.equals(MarkdownMetadata, a, b);
  }
}

/**
 * The URL is stored in properties, not here.
 *
 * @generated from message operand.v1.RSSMetadata
 */
export class RSSMetadata extends Message<RSSMetadata> {
  constructor(data?: PartialMessage<RSSMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.RSSMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RSSMetadata {
    return new RSSMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RSSMetadata {
    return new RSSMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RSSMetadata {
    return new RSSMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: RSSMetadata | PlainMessage<RSSMetadata> | undefined, b: RSSMetadata | PlainMessage<RSSMetadata> | undefined): boolean {
    return proto3.util.equals(RSSMetadata, a, b);
  }
}

/**
 * If the _url property is set, this metadata is auto-populated.
 *
 * @generated from message operand.v1.AudioMetadata
 */
export class AudioMetadata extends Message<AudioMetadata> {
  /**
   * @generated from field: optional operand.v1.AudioFileExt file_ext = 1;
   */
  fileExt?: AudioFileExt;

  /**
   * @generated from field: optional bytes audio = 2;
   */
  audio?: Uint8Array;

  constructor(data?: PartialMessage<AudioMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.AudioMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_ext", kind: "enum", T: proto3.getEnumType(AudioFileExt), opt: true },
    { no: 2, name: "audio", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioMetadata {
    return new AudioMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioMetadata {
    return new AudioMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioMetadata {
    return new AudioMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AudioMetadata | PlainMessage<AudioMetadata> | undefined, b: AudioMetadata | PlainMessage<AudioMetadata> | undefined): boolean {
    return proto3.util.equals(AudioMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.PodcastMetadata
 */
export class PodcastMetadata extends Message<PodcastMetadata> {
  /**
   * @generated from field: string listennotes_id = 1;
   */
  listennotesId = "";

  constructor(data?: PartialMessage<PodcastMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.PodcastMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "listennotes_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PodcastMetadata {
    return new PodcastMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PodcastMetadata {
    return new PodcastMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PodcastMetadata {
    return new PodcastMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PodcastMetadata | PlainMessage<PodcastMetadata> | undefined, b: PodcastMetadata | PlainMessage<PodcastMetadata> | undefined): boolean {
    return proto3.util.equals(PodcastMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.SitemapMetadata
 */
export class SitemapMetadata extends Message<SitemapMetadata> {
  /**
   * The URL is stored in properties, not here.
   *
   * @generated from field: optional string url_regex = 1;
   */
  urlRegex?: string;

  constructor(data?: PartialMessage<SitemapMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SitemapMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url_regex", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SitemapMetadata {
    return new SitemapMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SitemapMetadata {
    return new SitemapMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SitemapMetadata {
    return new SitemapMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SitemapMetadata | PlainMessage<SitemapMetadata> | undefined, b: SitemapMetadata | PlainMessage<SitemapMetadata> | undefined): boolean {
    return proto3.util.equals(SitemapMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.PDFMetadata
 */
export class PDFMetadata extends Message<PDFMetadata> {
  /**
   * @generated from field: optional bytes pdf = 1;
   */
  pdf?: Uint8Array;

  constructor(data?: PartialMessage<PDFMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.PDFMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pdf", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PDFMetadata {
    return new PDFMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PDFMetadata {
    return new PDFMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PDFMetadata {
    return new PDFMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PDFMetadata | PlainMessage<PDFMetadata> | undefined, b: PDFMetadata | PlainMessage<PDFMetadata> | undefined): boolean {
    return proto3.util.equals(PDFMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.EPUBMetadata
 */
export class EPUBMetadata extends Message<EPUBMetadata> {
  /**
   * @generated from field: optional bytes epub = 1;
   */
  epub?: Uint8Array;

  constructor(data?: PartialMessage<EPUBMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.EPUBMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epub", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EPUBMetadata {
    return new EPUBMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EPUBMetadata {
    return new EPUBMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EPUBMetadata {
    return new EPUBMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: EPUBMetadata | PlainMessage<EPUBMetadata> | undefined, b: EPUBMetadata | PlainMessage<EPUBMetadata> | undefined): boolean {
    return proto3.util.equals(EPUBMetadata, a, b);
  }
}

/**
 * The URL is stored in properties, not here.
 *
 * @generated from message operand.v1.YouTubeMetadata
 */
export class YouTubeMetadata extends Message<YouTubeMetadata> {
  constructor(data?: PartialMessage<YouTubeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.YouTubeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): YouTubeMetadata {
    return new YouTubeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): YouTubeMetadata {
    return new YouTubeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): YouTubeMetadata {
    return new YouTubeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: YouTubeMetadata | PlainMessage<YouTubeMetadata> | undefined, b: YouTubeMetadata | PlainMessage<YouTubeMetadata> | undefined): boolean {
    return proto3.util.equals(YouTubeMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.SlackMetadata
 */
export class SlackMetadata extends Message<SlackMetadata> {
  /**
   * @generated from field: string bot_token = 1;
   */
  botToken = "";

  /**
   * Will be set automatically.
   *
   * @generated from field: optional string bot_user_id = 2;
   */
  botUserId?: string;

  constructor(data?: PartialMessage<SlackMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SlackMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bot_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bot_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SlackMetadata {
    return new SlackMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SlackMetadata {
    return new SlackMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SlackMetadata {
    return new SlackMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SlackMetadata | PlainMessage<SlackMetadata> | undefined, b: SlackMetadata | PlainMessage<SlackMetadata> | undefined): boolean {
    return proto3.util.equals(SlackMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.GithubRepositoryMetadata
 */
export class GithubRepositoryMetadata extends Message<GithubRepositoryMetadata> {
  /**
   * @generated from field: string access_token = 1;
   */
  accessToken = "";

  /**
   * @generated from field: string owner = 2;
   */
  owner = "";

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: optional string ref = 4;
   */
  ref?: string;

  constructor(data?: PartialMessage<GithubRepositoryMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.GithubRepositoryMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ref", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubRepositoryMetadata {
    return new GithubRepositoryMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubRepositoryMetadata {
    return new GithubRepositoryMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubRepositoryMetadata {
    return new GithubRepositoryMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: GithubRepositoryMetadata | PlainMessage<GithubRepositoryMetadata> | undefined, b: GithubRepositoryMetadata | PlainMessage<GithubRepositoryMetadata> | undefined): boolean {
    return proto3.util.equals(GithubRepositoryMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.SourceCodeMetadata
 */
export class SourceCodeMetadata extends Message<SourceCodeMetadata> {
  /**
   * @generated from field: operand.v1.ProgrammingLanguage language = 1;
   */
  language = ProgrammingLanguage.UNSPECIFIED;

  /**
   * @generated from field: string source_code = 2;
   */
  sourceCode = "";

  constructor(data?: PartialMessage<SourceCodeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SourceCodeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "language", kind: "enum", T: proto3.getEnumType(ProgrammingLanguage) },
    { no: 2, name: "source_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceCodeMetadata {
    return new SourceCodeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceCodeMetadata {
    return new SourceCodeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceCodeMetadata {
    return new SourceCodeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SourceCodeMetadata | PlainMessage<SourceCodeMetadata> | undefined, b: SourceCodeMetadata | PlainMessage<SourceCodeMetadata> | undefined): boolean {
    return proto3.util.equals(SourceCodeMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.NotionMetadata
 */
export class NotionMetadata extends Message<NotionMetadata> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<NotionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.NotionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotionMetadata {
    return new NotionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotionMetadata {
    return new NotionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotionMetadata {
    return new NotionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NotionMetadata | PlainMessage<NotionMetadata> | undefined, b: NotionMetadata | PlainMessage<NotionMetadata> | undefined): boolean {
    return proto3.util.equals(NotionMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.DiscordMetadata
 */
export class DiscordMetadata extends Message<DiscordMetadata> {
  /**
   * @generated from field: string guild_id = 1;
   */
  guildId = "";

  constructor(data?: PartialMessage<DiscordMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.DiscordMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "guild_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscordMetadata {
    return new DiscordMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscordMetadata {
    return new DiscordMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscordMetadata {
    return new DiscordMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DiscordMetadata | PlainMessage<DiscordMetadata> | undefined, b: DiscordMetadata | PlainMessage<DiscordMetadata> | undefined): boolean {
    return proto3.util.equals(DiscordMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.LinearMetadata
 */
export class LinearMetadata extends Message<LinearMetadata> {
  /**
   * @generated from field: string access_token = 1;
   */
  accessToken = "";

  constructor(data?: PartialMessage<LinearMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.LinearMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinearMetadata {
    return new LinearMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinearMetadata {
    return new LinearMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinearMetadata {
    return new LinearMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: LinearMetadata | PlainMessage<LinearMetadata> | undefined, b: LinearMetadata | PlainMessage<LinearMetadata> | undefined): boolean {
    return proto3.util.equals(LinearMetadata, a, b);
  }
}

/**
 * @generated from message operand.v1.Properties
 */
export class Properties extends Message<Properties> {
  /**
   * @generated from field: map<string, operand.v1.Property> properties = 1;
   */
  properties: { [key: string]: Property } = {};

  constructor(data?: PartialMessage<Properties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Properties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Property} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Properties {
    return new Properties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJsonString(jsonString, options);
  }

  static equals(a: Properties | PlainMessage<Properties> | undefined, b: Properties | PlainMessage<Properties> | undefined): boolean {
    return proto3.util.equals(Properties, a, b);
  }
}

/**
 * @generated from message operand.v1.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from field: bool indexed = 1;
   */
  indexed = false;

  /**
   * @generated from oneof operand.v1.Property.value
   */
  value: {
    /**
     * @generated from field: string text = 2;
     */
    value: string;
    case: "text";
  } | {
    /**
     * @generated from field: double number = 3;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: operand.v1.TextArray text_array = 4;
     */
    value: TextArray;
    case: "textArray";
  } | {
    /**
     * @generated from field: operand.v1.NumberArray number_array = 5;
     */
    value: NumberArray;
    case: "numberArray";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "indexed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 4, name: "text_array", kind: "message", T: TextArray, oneof: "value" },
    { no: 5, name: "number_array", kind: "message", T: NumberArray, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * @generated from message operand.v1.TextArray
 */
export class TextArray extends Message<TextArray> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<TextArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.TextArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextArray {
    return new TextArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJsonString(jsonString, options);
  }

  static equals(a: TextArray | PlainMessage<TextArray> | undefined, b: TextArray | PlainMessage<TextArray> | undefined): boolean {
    return proto3.util.equals(TextArray, a, b);
  }
}

/**
 * @generated from message operand.v1.NumberArray
 */
export class NumberArray extends Message<NumberArray> {
  /**
   * @generated from field: repeated double values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<NumberArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.NumberArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumberArray {
    return new NumberArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJsonString(jsonString, options);
  }

  static equals(a: NumberArray | PlainMessage<NumberArray> | undefined, b: NumberArray | PlainMessage<NumberArray> | undefined): boolean {
    return proto3.util.equals(NumberArray, a, b);
  }
}

/**
 * @generated from message operand.v1.ObjectPreview
 */
export class ObjectPreview extends Message<ObjectPreview> {
  /**
   * @generated from field: optional string title = 1;
   */
  title?: string;

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * @generated from field: optional string image = 3;
   */
  image?: string;

  /**
   * @generated from field: optional string url = 4;
   */
  url?: string;

  constructor(data?: PartialMessage<ObjectPreview>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.ObjectPreview";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectPreview {
    return new ObjectPreview().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectPreview {
    return new ObjectPreview().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectPreview {
    return new ObjectPreview().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectPreview | PlainMessage<ObjectPreview> | undefined, b: ObjectPreview | PlainMessage<ObjectPreview> | undefined): boolean {
    return proto3.util.equals(ObjectPreview, a, b);
  }
}

/**
 * @generated from message operand.v1.IndexingProgress
 */
export class IndexingProgress extends Message<IndexingProgress> {
  /**
   * 0.0 - 1.0
   *
   * @generated from field: float percent_ready = 1;
   */
  percentReady = 0;

  /**
   * @generated from field: map<string, int32> status_counts = 2;
   */
  statusCounts: { [key: string]: number } = {};

  constructor(data?: PartialMessage<IndexingProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.IndexingProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "percent_ready", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "status_counts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexingProgress {
    return new IndexingProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexingProgress {
    return new IndexingProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexingProgress {
    return new IndexingProgress().fromJsonString(jsonString, options);
  }

  static equals(a: IndexingProgress | PlainMessage<IndexingProgress> | undefined, b: IndexingProgress | PlainMessage<IndexingProgress> | undefined): boolean {
    return proto3.util.equals(IndexingProgress, a, b);
  }
}

/**
 * @generated from message operand.v1.Object
 */
export class Object$ extends Message<Object$> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp updated_at = 3;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: optional string parent_id = 4;
   */
  parentId?: string;

  /**
   * @generated from field: operand.v1.ObjectType type = 5;
   */
  type = ObjectType.UNSPECIFIED;

  /**
   * @generated from field: optional operand.v1.ObjectMetadata metadata = 6;
   */
  metadata?: ObjectMetadata;

  /**
   * @generated from field: operand.v1.Properties properties = 7;
   */
  properties?: Properties;

  /**
   * @generated from field: operand.v1.ObjectStatus status = 8;
   */
  status = ObjectStatus.UNSPECIFIED;

  /**
   * @generated from field: optional operand.v1.ObjectPreview preview = 9;
   */
  preview?: ObjectPreview;

  /**
   * @generated from field: optional operand.v1.IndexingProgress indexing_progress = 10;
   */
  indexingProgress?: IndexingProgress;

  /**
   * @generated from field: optional string error = 11;
   */
  error?: string;

  constructor(data?: PartialMessage<Object$>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "updated_at", kind: "message", T: Timestamp, opt: true },
    { no: 4, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "type", kind: "enum", T: proto3.getEnumType(ObjectType) },
    { no: 6, name: "metadata", kind: "message", T: ObjectMetadata, opt: true },
    { no: 7, name: "properties", kind: "message", T: Properties },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(ObjectStatus) },
    { no: 9, name: "preview", kind: "message", T: ObjectPreview, opt: true },
    { no: 10, name: "indexing_progress", kind: "message", T: IndexingProgress, opt: true },
    { no: 11, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object$ {
    return new Object$().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJsonString(jsonString, options);
  }

  static equals(a: Object$ | PlainMessage<Object$> | undefined, b: Object$ | PlainMessage<Object$> | undefined): boolean {
    return proto3.util.equals(Object$, a, b);
  }
}

/**
 * @generated from message operand.v1.ObjectOptions
 */
export class ObjectOptions extends Message<ObjectOptions> {
  /**
   * @generated from field: optional bool include_metadata = 1;
   */
  includeMetadata?: boolean;

  /**
   * @generated from field: optional bool include_preview = 2;
   */
  includePreview?: boolean;

  /**
   * @generated from field: optional bool include_indexing_progress = 3;
   */
  includeIndexingProgress?: boolean;

  constructor(data?: PartialMessage<ObjectOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.ObjectOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include_metadata", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "include_preview", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "include_indexing_progress", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectOptions {
    return new ObjectOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectOptions {
    return new ObjectOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectOptions {
    return new ObjectOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectOptions | PlainMessage<ObjectOptions> | undefined, b: ObjectOptions | PlainMessage<ObjectOptions> | undefined): boolean {
    return proto3.util.equals(ObjectOptions, a, b);
  }
}

/**
 * @generated from message operand.v1.UpsertRequest
 */
export class UpsertRequest extends Message<UpsertRequest> {
  /**
   * @generated from field: optional string existing_id = 1;
   */
  existingId?: string;

  /**
   * @generated from field: optional string parent_id = 2;
   */
  parentId?: string;

  /**
   * @generated from field: optional operand.v1.ObjectType type = 3;
   */
  type?: ObjectType;

  /**
   * @generated from field: optional operand.v1.ObjectMetadata metadata = 4;
   */
  metadata?: ObjectMetadata;

  /**
   * @generated from field: optional operand.v1.Properties properties = 5;
   */
  properties?: Properties;

  /**
   * If specified, we'll set `existing_id` to any existing object with the same `unique_property`.
   * This is used to deduplicate objects, i.e. by their URL (or some other property which the application
   * considers to be unique).
   *
   * @generated from field: optional string unique_property = 6;
   */
  uniqueProperty?: string;

  constructor(data?: PartialMessage<UpsertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.UpsertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "existing_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(ObjectType), opt: true },
    { no: 4, name: "metadata", kind: "message", T: ObjectMetadata, opt: true },
    { no: 5, name: "properties", kind: "message", T: Properties, opt: true },
    { no: 6, name: "unique_property", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertRequest {
    return new UpsertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertRequest {
    return new UpsertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertRequest {
    return new UpsertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertRequest | PlainMessage<UpsertRequest> | undefined, b: UpsertRequest | PlainMessage<UpsertRequest> | undefined): boolean {
    return proto3.util.equals(UpsertRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.UpsertResponse
 */
export class UpsertResponse extends Message<UpsertResponse> {
  /**
   * @generated from field: operand.v1.Object object = 1;
   */
  object?: Object$;

  constructor(data?: PartialMessage<UpsertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.UpsertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Object$ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertResponse {
    return new UpsertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertResponse {
    return new UpsertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertResponse {
    return new UpsertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertResponse | PlainMessage<UpsertResponse> | undefined, b: UpsertResponse | PlainMessage<UpsertResponse> | undefined): boolean {
    return proto3.util.equals(UpsertResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.SuggestionsRequest
 */
export class SuggestionsRequest extends Message<SuggestionsRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: optional operand.v1.ObjectType type = 2;
   */
  type?: ObjectType;

  constructor(data?: PartialMessage<SuggestionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SuggestionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ObjectType), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuggestionsRequest {
    return new SuggestionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuggestionsRequest {
    return new SuggestionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuggestionsRequest {
    return new SuggestionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SuggestionsRequest | PlainMessage<SuggestionsRequest> | undefined, b: SuggestionsRequest | PlainMessage<SuggestionsRequest> | undefined): boolean {
    return proto3.util.equals(SuggestionsRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.SuggestionsResponse
 */
export class SuggestionsResponse extends Message<SuggestionsResponse> {
  /**
   * @generated from field: repeated operand.v1.SuggestionsResponse.AnnotatedUpsert upserts = 1;
   */
  upserts: SuggestionsResponse_AnnotatedUpsert[] = [];

  constructor(data?: PartialMessage<SuggestionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SuggestionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "upserts", kind: "message", T: SuggestionsResponse_AnnotatedUpsert, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuggestionsResponse {
    return new SuggestionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuggestionsResponse {
    return new SuggestionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuggestionsResponse {
    return new SuggestionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SuggestionsResponse | PlainMessage<SuggestionsResponse> | undefined, b: SuggestionsResponse | PlainMessage<SuggestionsResponse> | undefined): boolean {
    return proto3.util.equals(SuggestionsResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.SuggestionsResponse.AnnotatedUpsert
 */
export class SuggestionsResponse_AnnotatedUpsert extends Message<SuggestionsResponse_AnnotatedUpsert> {
  /**
   * @generated from field: operand.v1.UpsertRequest upsert = 1;
   */
  upsert?: UpsertRequest;

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: optional int32 page_estimate = 3;
   */
  pageEstimate?: number;

  constructor(data?: PartialMessage<SuggestionsResponse_AnnotatedUpsert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SuggestionsResponse.AnnotatedUpsert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "upsert", kind: "message", T: UpsertRequest },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_estimate", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuggestionsResponse_AnnotatedUpsert {
    return new SuggestionsResponse_AnnotatedUpsert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuggestionsResponse_AnnotatedUpsert {
    return new SuggestionsResponse_AnnotatedUpsert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuggestionsResponse_AnnotatedUpsert {
    return new SuggestionsResponse_AnnotatedUpsert().fromJsonString(jsonString, options);
  }

  static equals(a: SuggestionsResponse_AnnotatedUpsert | PlainMessage<SuggestionsResponse_AnnotatedUpsert> | undefined, b: SuggestionsResponse_AnnotatedUpsert | PlainMessage<SuggestionsResponse_AnnotatedUpsert> | undefined): boolean {
    return proto3.util.equals(SuggestionsResponse_AnnotatedUpsert, a, b);
  }
}

/**
 * @generated from message operand.v1.ListRequest
 */
export class ListRequest extends Message<ListRequest> {
  /**
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * @generated from field: optional string cursor = 2;
   */
  cursor?: string;

  /**
   * @generated from field: optional int32 limit = 3;
   */
  limit?: number;

  /**
   * @generated from field: optional operand.v1.ObjectOptions options = 4;
   */
  options?: ObjectOptions;

  constructor(data?: PartialMessage<ListRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.ListRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "options", kind: "message", T: ObjectOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRequest {
    return new ListRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRequest {
    return new ListRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRequest {
    return new ListRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListRequest | PlainMessage<ListRequest> | undefined, b: ListRequest | PlainMessage<ListRequest> | undefined): boolean {
    return proto3.util.equals(ListRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.ListResponse
 */
export class ListResponse extends Message<ListResponse> {
  /**
   * @generated from field: repeated operand.v1.Object objects = 1;
   */
  objects: Object$[] = [];

  /**
   * @generated from field: optional string next_cursor = 2;
   */
  nextCursor?: string;

  constructor(data?: PartialMessage<ListResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.ListResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects", kind: "message", T: Object$, repeated: true },
    { no: 2, name: "next_cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListResponse {
    return new ListResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListResponse {
    return new ListResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListResponse {
    return new ListResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListResponse | PlainMessage<ListResponse> | undefined, b: ListResponse | PlainMessage<ListResponse> | undefined): boolean {
    return proto3.util.equals(ListResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.GetRequest
 */
export class GetRequest extends Message<GetRequest> {
  /**
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  /**
   * @generated from field: optional operand.v1.ObjectOptions options = 2;
   */
  options?: ObjectOptions;

  constructor(data?: PartialMessage<GetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.GetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "options", kind: "message", T: ObjectOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRequest {
    return new GetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRequest | PlainMessage<GetRequest> | undefined, b: GetRequest | PlainMessage<GetRequest> | undefined): boolean {
    return proto3.util.equals(GetRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.GetResponse
 */
export class GetResponse extends Message<GetResponse> {
  /**
   * @generated from field: repeated operand.v1.Object objects = 1;
   */
  objects: Object$[] = [];

  constructor(data?: PartialMessage<GetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.GetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects", kind: "message", T: Object$, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResponse {
    return new GetResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetResponse | PlainMessage<GetResponse> | undefined, b: GetResponse | PlainMessage<GetResponse> | undefined): boolean {
    return proto3.util.equals(GetResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.DeleteRequest
 */
export class DeleteRequest extends Message<DeleteRequest> {
  /**
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<DeleteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.DeleteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRequest {
    return new DeleteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRequest {
    return new DeleteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRequest {
    return new DeleteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRequest | PlainMessage<DeleteRequest> | undefined, b: DeleteRequest | PlainMessage<DeleteRequest> | undefined): boolean {
    return proto3.util.equals(DeleteRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.DeleteResponse
 */
export class DeleteResponse extends Message<DeleteResponse> {
  constructor(data?: PartialMessage<DeleteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.DeleteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteResponse {
    return new DeleteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteResponse {
    return new DeleteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteResponse {
    return new DeleteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteResponse | PlainMessage<DeleteResponse> | undefined, b: DeleteResponse | PlainMessage<DeleteResponse> | undefined): boolean {
    return proto3.util.equals(DeleteResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.CountRequest
 */
export class CountRequest extends Message<CountRequest> {
  /**
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  constructor(data?: PartialMessage<CountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.CountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountRequest {
    return new CountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountRequest {
    return new CountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountRequest {
    return new CountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountRequest | PlainMessage<CountRequest> | undefined, b: CountRequest | PlainMessage<CountRequest> | undefined): boolean {
    return proto3.util.equals(CountRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.CountResponse
 */
export class CountResponse extends Message<CountResponse> {
  /**
   * @generated from field: int32 count = 1;
   */
  count = 0;

  constructor(data?: PartialMessage<CountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.CountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResponse {
    return new CountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountResponse | PlainMessage<CountResponse> | undefined, b: CountResponse | PlainMessage<CountResponse> | undefined): boolean {
    return proto3.util.equals(CountResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * @generated from field: repeated operand.v1.Condition conditions = 1;
   */
  conditions: Condition[] = [];

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: Condition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * @generated from message operand.v1.NotCondition
 */
export class NotCondition extends Message<NotCondition> {
  /**
   * @generated from field: operand.v1.Condition condition = 1;
   */
  condition?: Condition;

  constructor(data?: PartialMessage<NotCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.NotCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition", kind: "message", T: Condition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotCondition {
    return new NotCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotCondition {
    return new NotCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotCondition {
    return new NotCondition().fromJsonString(jsonString, options);
  }

  static equals(a: NotCondition | PlainMessage<NotCondition> | undefined, b: NotCondition | PlainMessage<NotCondition> | undefined): boolean {
    return proto3.util.equals(NotCondition, a, b);
  }
}

/**
 * @generated from message operand.v1.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * @generated from oneof operand.v1.Condition.condition
   */
  condition: {
    /**
     * @generated from field: operand.v1.KeyedProperty property = 1;
     */
    value: KeyedProperty;
    case: "property";
  } | {
    /**
     * @generated from field: operand.v1.Range range = 2;
     */
    value: Range;
    case: "range";
  } | {
    /**
     * @generated from field: operand.v1.Filter and = 3;
     */
    value: Filter;
    case: "and";
  } | {
    /**
     * @generated from field: operand.v1.Filter or = 4;
     */
    value: Filter;
    case: "or";
  } | {
    /**
     * @generated from field: operand.v1.NotCondition not = 5;
     */
    value: NotCondition;
    case: "not";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: KeyedProperty, oneof: "condition" },
    { no: 2, name: "range", kind: "message", T: Range, oneof: "condition" },
    { no: 3, name: "and", kind: "message", T: Filter, oneof: "condition" },
    { no: 4, name: "or", kind: "message", T: Filter, oneof: "condition" },
    { no: 5, name: "not", kind: "message", T: NotCondition, oneof: "condition" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

/**
 * @generated from message operand.v1.KeyedProperty
 */
export class KeyedProperty extends Message<KeyedProperty> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: operand.v1.Property property = 2;
   */
  property?: Property;

  constructor(data?: PartialMessage<KeyedProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.KeyedProperty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "property", kind: "message", T: Property },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyedProperty {
    return new KeyedProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyedProperty {
    return new KeyedProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyedProperty {
    return new KeyedProperty().fromJsonString(jsonString, options);
  }

  static equals(a: KeyedProperty | PlainMessage<KeyedProperty> | undefined, b: KeyedProperty | PlainMessage<KeyedProperty> | undefined): boolean {
    return proto3.util.equals(KeyedProperty, a, b);
  }
}

/**
 * @generated from message operand.v1.Range
 */
export class Range extends Message<Range> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: optional double lt = 2;
   */
  lt?: number;

  /**
   * @generated from field: optional double lte = 3;
   */
  lte?: number;

  /**
   * @generated from field: optional double gt = 4;
   */
  gt?: number;

  /**
   * @generated from field: optional double gte = 5;
   */
  gte?: number;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "lt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "lte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "gt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 5, name: "gte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * @generated from message operand.v1.SearchWithinRequest
 */
export class SearchWithinRequest extends Message<SearchWithinRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: optional int32 limit = 2;
   */
  limit?: number;

  /**
   * Can only be used over indexed properties.
   *
   * @generated from field: optional operand.v1.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * @generated from field: optional operand.v1.ObjectOptions object_options = 4;
   */
  objectOptions?: ObjectOptions;

  constructor(data?: PartialMessage<SearchWithinRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchWithinRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 4, name: "object_options", kind: "message", T: ObjectOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchWithinRequest {
    return new SearchWithinRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchWithinRequest {
    return new SearchWithinRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchWithinRequest {
    return new SearchWithinRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchWithinRequest | PlainMessage<SearchWithinRequest> | undefined, b: SearchWithinRequest | PlainMessage<SearchWithinRequest> | undefined): boolean {
    return proto3.util.equals(SearchWithinRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.SearchWithinResponse
 */
export class SearchWithinResponse extends Message<SearchWithinResponse> {
  /**
   * @generated from field: repeated operand.v1.SearchWithinResponse.Match matches = 1;
   */
  matches: SearchWithinResponse_Match[] = [];

  /**
   * @generated from field: map<string, operand.v1.Object> objects = 2;
   */
  objects: { [key: string]: Object$ } = {};

  constructor(data?: PartialMessage<SearchWithinResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchWithinResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "matches", kind: "message", T: SearchWithinResponse_Match, repeated: true },
    { no: 2, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Object$} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchWithinResponse {
    return new SearchWithinResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchWithinResponse {
    return new SearchWithinResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchWithinResponse {
    return new SearchWithinResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchWithinResponse | PlainMessage<SearchWithinResponse> | undefined, b: SearchWithinResponse | PlainMessage<SearchWithinResponse> | undefined): boolean {
    return proto3.util.equals(SearchWithinResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.SearchWithinResponse.Match
 */
export class SearchWithinResponse_Match extends Message<SearchWithinResponse_Match> {
  /**
   * @generated from field: string match_id = 1;
   */
  matchId = "";

  /**
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  /**
   * @generated from field: string content = 3;
   */
  content = "";

  /**
   * @generated from field: float score = 4;
   */
  score = 0;

  /**
   * @generated from field: optional operand.v1.Properties extra = 5;
   */
  extra?: Properties;

  constructor(data?: PartialMessage<SearchWithinResponse_Match>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchWithinResponse.Match";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "extra", kind: "message", T: Properties, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchWithinResponse_Match {
    return new SearchWithinResponse_Match().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchWithinResponse_Match {
    return new SearchWithinResponse_Match().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchWithinResponse_Match {
    return new SearchWithinResponse_Match().fromJsonString(jsonString, options);
  }

  static equals(a: SearchWithinResponse_Match | PlainMessage<SearchWithinResponse_Match> | undefined, b: SearchWithinResponse_Match | PlainMessage<SearchWithinResponse_Match> | undefined): boolean {
    return proto3.util.equals(SearchWithinResponse_Match, a, b);
  }
}

/**
 * Answer is an attempt to answer a question.
 *
 * @generated from message operand.v1.Answer
 */
export class Answer extends Message<Answer> {
  /**
   * @generated from field: string answer = 1;
   */
  answer = "";

  /**
   * Confidence is a value between 0 and 1, where 1 is the highest confidence.
   * It indicates how confident we are that the answer is factually correct, using
   * the index content as the ground truth.
   *
   * @generated from field: float confidence = 2;
   */
  confidence = 0;

  constructor(data?: PartialMessage<Answer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.Answer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Answer {
    return new Answer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJsonString(jsonString, options);
  }

  static equals(a: Answer | PlainMessage<Answer> | undefined, b: Answer | PlainMessage<Answer> | undefined): boolean {
    return proto3.util.equals(Answer, a, b);
  }
}

/**
 * @generated from message operand.v1.AnswerRequest
 */
export class AnswerRequest extends Message<AnswerRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: optional operand.v1.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * @generated from field: optional operand.v1.ObjectOptions object_options = 3;
   */
  objectOptions?: ObjectOptions;

  constructor(data?: PartialMessage<AnswerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.AnswerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 3, name: "object_options", kind: "message", T: ObjectOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerRequest {
    return new AnswerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerRequest {
    return new AnswerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerRequest {
    return new AnswerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerRequest | PlainMessage<AnswerRequest> | undefined, b: AnswerRequest | PlainMessage<AnswerRequest> | undefined): boolean {
    return proto3.util.equals(AnswerRequest, a, b);
  }
}

/**
 * @generated from message operand.v1.AnswerResponse
 */
export class AnswerResponse extends Message<AnswerResponse> {
  /**
   * @generated from field: optional operand.v1.Answer answer = 1;
   */
  answer?: Answer;

  /**
   * @generated from field: repeated operand.v1.Object sources = 2;
   */
  sources: Object$[] = [];

  constructor(data?: PartialMessage<AnswerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.AnswerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer", kind: "message", T: Answer, opt: true },
    { no: 2, name: "sources", kind: "message", T: Object$, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerResponse {
    return new AnswerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerResponse {
    return new AnswerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerResponse {
    return new AnswerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerResponse | PlainMessage<AnswerResponse> | undefined, b: AnswerResponse | PlainMessage<AnswerResponse> | undefined): boolean {
    return proto3.util.equals(AnswerResponse, a, b);
  }
}

