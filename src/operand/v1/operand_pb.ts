// @generated by protoc-gen-es v0.1.1 with parameter "target=ts+js"
// @generated from file operand/v1/operand.proto (package operand.v1, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, Timestamp} from "@bufbuild/protobuf";
import {Answer, Object$, ObjectOptions, Properties} from "./object_pb.js";
import {Index, IndexOptions} from "./index_pb.js";

/**
 * PaginationParams are the parameters used to paginate a feed.
 *
 * @generated from message operand.v1.PaginationParams
 */
export class PaginationParams extends Message<PaginationParams> {
  /**
   * @generated from field: int32 limit = 1;
   */
  limit = 0;

  /**
   * @generated from field: optional int32 offset = 2;
   */
  offset?: number;

  /**
   * Latest time is the time to start the feed from. If this is not specified, the feed will start from
   * the most recent object, i.e. the current time. This is important as it helps ensure pagination
   * remains consistent, even if new objects are being indexed as part of the users feed. We expect the
   * caller to periodically "refresh" the feed by adjusting the latest time to the current time and perhaps
   * merging the results with the previously fetched feed.
   *
   * @generated from field: optional google.protobuf.Timestamp latest_time = 3;
   */
  latestTime?: Timestamp;

  constructor(data?: PartialMessage<PaginationParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.PaginationParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "offset", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "latest_time", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationParams {
    return new PaginationParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationParams {
    return new PaginationParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationParams {
    return new PaginationParams().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationParams | PlainMessage<PaginationParams> | undefined, b: PaginationParams | PlainMessage<PaginationParams> | undefined): boolean {
    return proto3.util.equals(PaginationParams, a, b);
  }
}

/**
 * FeedRequest is the request object for the Feed RPC.
 *
 * @generated from message operand.v1.FeedRequest
 */
export class FeedRequest extends Message<FeedRequest> {
  /**
   * If the user doesn't specify a specific index to get the feed from, then we will return a combined
   * feed of all of the indexes that they've subscribed to.
   *
   * @generated from field: optional string specific_index_id = 1;
   */
  specificIndexId?: string;

  /**
   * @generated from field: optional operand.v1.PaginationParams pagination_params = 2;
   */
  paginationParams?: PaginationParams;

  /**
   * @generated from field: optional operand.v1.ObjectOptions object_options = 3;
   */
  objectOptions?: ObjectOptions;

  /**
   * @generated from field: optional operand.v1.IndexOptions index_options = 4;
   */
  indexOptions?: IndexOptions;

  constructor(data?: PartialMessage<FeedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.FeedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "specific_index_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "pagination_params", kind: "message", T: PaginationParams, opt: true },
    { no: 3, name: "object_options", kind: "message", T: ObjectOptions, opt: true },
    { no: 4, name: "index_options", kind: "message", T: IndexOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedRequest {
    return new FeedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedRequest {
    return new FeedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedRequest {
    return new FeedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FeedRequest | PlainMessage<FeedRequest> | undefined, b: FeedRequest | PlainMessage<FeedRequest> | undefined): boolean {
    return proto3.util.equals(FeedRequest, a, b);
  }
}

/**
 * FeedResponse is the response object for the Feed RPC.
 *
 * @generated from message operand.v1.FeedResponse
 */
export class FeedResponse extends Message<FeedResponse> {
  /**
   * @generated from field: repeated operand.v1.FeedResponse.FeedObject feed_objects = 1;
   */
  feedObjects: FeedResponse_FeedObject[] = [];

  /**
   * @generated from field: map<string, operand.v1.Index> indexes = 2;
   */
  indexes: { [key: string]: Index } = {};

  constructor(data?: PartialMessage<FeedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.FeedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_objects", kind: "message", T: FeedResponse_FeedObject, repeated: true },
    { no: 2, name: "indexes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Index} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedResponse {
    return new FeedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedResponse {
    return new FeedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedResponse {
    return new FeedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FeedResponse | PlainMessage<FeedResponse> | undefined, b: FeedResponse | PlainMessage<FeedResponse> | undefined): boolean {
    return proto3.util.equals(FeedResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.FeedResponse.FeedObject
 */
export class FeedResponse_FeedObject extends Message<FeedResponse_FeedObject> {
  /**
   * @generated from field: string index_id = 1;
   */
  indexId = "";

  /**
   * @generated from field: operand.v1.Object object = 2;
   */
  object?: Object$;

  constructor(data?: PartialMessage<FeedResponse_FeedObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.FeedResponse.FeedObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object", kind: "message", T: Object$ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedResponse_FeedObject {
    return new FeedResponse_FeedObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedResponse_FeedObject {
    return new FeedResponse_FeedObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedResponse_FeedObject {
    return new FeedResponse_FeedObject().fromJsonString(jsonString, options);
  }

  static equals(a: FeedResponse_FeedObject | PlainMessage<FeedResponse_FeedObject> | undefined, b: FeedResponse_FeedObject | PlainMessage<FeedResponse_FeedObject> | undefined): boolean {
    return proto3.util.equals(FeedResponse_FeedObject, a, b);
  }
}

/**
 * SearchRequest is the request object for the Search RPC.
 *
 * @generated from message operand.v1.SearchRequest
 */
export class SearchRequest extends Message<SearchRequest> {
  /**
   * @generated from field: repeated string index_ids = 1;
   */
  indexIds: string[] = [];

  /**
   * @generated from field: string query = 2;
   */
  query = "";

  /**
   * @generated from field: optional int32 limit = 3;
   */
  limit?: number;

  /**
   * @generated from field: optional bool attempt_answer = 4;
   */
  attemptAnswer?: boolean;

  /**
   * @generated from field: optional operand.v1.ObjectOptions object_options = 5;
   */
  objectOptions?: ObjectOptions;

  /**
   * @generated from field: optional operand.v1.IndexOptions index_options = 6;
   */
  indexOptions?: IndexOptions;

  constructor(data?: PartialMessage<SearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "attempt_answer", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "object_options", kind: "message", T: ObjectOptions, opt: true },
    { no: 6, name: "index_options", kind: "message", T: IndexOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest {
    return new SearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRequest | PlainMessage<SearchRequest> | undefined, b: SearchRequest | PlainMessage<SearchRequest> | undefined): boolean {
    return proto3.util.equals(SearchRequest, a, b);
  }
}

/**
 * SearchResponse is the response object for the Search RPC.
 *
 * @generated from message operand.v1.SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: repeated operand.v1.SearchResponse.Result results = 1;
   */
  results: SearchResponse_Result[] = [];

  /**
   * @generated from field: map<string, operand.v1.Object> objects = 2;
   */
  objects: { [key: string]: Object$ } = {};

  /**
   * @generated from field: map<string, operand.v1.Index> indexes = 3;
   */
  indexes: { [key: string]: Index } = {};

  /**
   * @generated from field: optional operand.v1.Answer answer = 4;
   */
  answer?: Answer;

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: SearchResponse_Result, repeated: true },
    { no: 2, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Object$} },
    { no: 3, name: "indexes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Index} },
    { no: 4, name: "answer", kind: "message", T: Answer, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * @generated from message operand.v1.SearchResponse.Result
 */
export class SearchResponse_Result extends Message<SearchResponse_Result> {
  /**
   * @generated from field: string index_id = 1;
   */
  indexId = "";

  /**
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  /**
   * @generated from field: string content = 3;
   */
  content = "";

  /**
   * @generated from field: optional operand.v1.Properties extra = 4;
   */
  extra?: Properties;

  constructor(data?: PartialMessage<SearchResponse_Result>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.SearchResponse.Result";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "extra", kind: "message", T: Properties, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse_Result {
    return new SearchResponse_Result().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse_Result {
    return new SearchResponse_Result().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse_Result {
    return new SearchResponse_Result().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse_Result | PlainMessage<SearchResponse_Result> | undefined, b: SearchResponse_Result | PlainMessage<SearchResponse_Result> | undefined): boolean {
    return proto3.util.equals(SearchResponse_Result, a, b);
  }
}

/**
 * PublicIndexesRequest is the request object for the PublicIndexes RPC.
 *
 * @generated from message operand.v1.PublicIndexesRequest
 */
export class PublicIndexesRequest extends Message<PublicIndexesRequest> {
  /**
   * @generated from field: optional string query = 1;
   */
  query?: string;

  /**
   * @generated from field: optional int32 limit = 2;
   */
  limit?: number;

  /**
   * @generated from field: optional operand.v1.IndexOptions index_options = 3;
   */
  indexOptions?: IndexOptions;

  constructor(data?: PartialMessage<PublicIndexesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.PublicIndexesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "index_options", kind: "message", T: IndexOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicIndexesRequest {
    return new PublicIndexesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicIndexesRequest {
    return new PublicIndexesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicIndexesRequest {
    return new PublicIndexesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublicIndexesRequest | PlainMessage<PublicIndexesRequest> | undefined, b: PublicIndexesRequest | PlainMessage<PublicIndexesRequest> | undefined): boolean {
    return proto3.util.equals(PublicIndexesRequest, a, b);
  }
}

/**
 * PublicIndexesResponse is the response object for the PublicIndexes RPC.
 *
 * @generated from message operand.v1.PublicIndexesResponse
 */
export class PublicIndexesResponse extends Message<PublicIndexesResponse> {
  /**
   * @generated from field: repeated operand.v1.Index indexes = 1;
   */
  indexes: Index[] = [];

  constructor(data?: PartialMessage<PublicIndexesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "operand.v1.PublicIndexesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "indexes", kind: "message", T: Index, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicIndexesResponse {
    return new PublicIndexesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicIndexesResponse {
    return new PublicIndexesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicIndexesResponse {
    return new PublicIndexesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PublicIndexesResponse | PlainMessage<PublicIndexesResponse> | undefined, b: PublicIndexesResponse | PlainMessage<PublicIndexesResponse> | undefined): boolean {
    return proto3.util.equals(PublicIndexesResponse, a, b);
  }
}

