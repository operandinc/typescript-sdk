// @generated by protoc-gen-es v0.1.1 with parameter "target=ts+js"
// @generated from file index/v1/index.proto (package index.v1, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, Timestamp} from "@bufbuild/protobuf";

/**
 * @generated from enum index.v1.ObjectType
 */
export enum ObjectType {
  /**
   * @generated from enum value: OBJECT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OBJECT_TYPE_COLLECTION = 1;
   */
  COLLECTION = 1,

  /**
   * @generated from enum value: OBJECT_TYPE_TEXT = 2;
   */
  TEXT = 2,

  /**
   * @generated from enum value: OBJECT_TYPE_HTML = 3;
   */
  HTML = 3,

  /**
   * @generated from enum value: OBJECT_TYPE_IMAGE = 4;
   */
  IMAGE = 4,

  /**
   * @generated from enum value: OBJECT_TYPE_PDF = 5;
   */
  PDF = 5,

  /**
   * @generated from enum value: OBJECT_TYPE_AUDIO = 6;
   */
  AUDIO = 6,

  /**
   * Slack is a unique object type, which requires some additional work
   * on the client side to get working. First off, when the object is first
   * created, we'll do a fetch of all the messages that we have access to,
   * i.e. all the channels that we've been added to. Following this, we await
   * webhook events from Slack, sent via the Webhook API method of this service.
   * We expect the client to essentially reverse proxy certain slack webhooks to
   * the correct object ID, which we'll then use to update the object. Specifically,
   * we support webhooks when we're added to a new channel, and when a new message
   * is posted to a channel we're part of.
   *
   * @generated from enum value: OBJECT_TYPE_SLACK = 7;
   */
  SLACK = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(ObjectType)
proto3.util.setEnumType(ObjectType, "index.v1.ObjectType", [
  { no: 0, name: "OBJECT_TYPE_UNSPECIFIED" },
  { no: 1, name: "OBJECT_TYPE_COLLECTION" },
  { no: 2, name: "OBJECT_TYPE_TEXT" },
  { no: 3, name: "OBJECT_TYPE_HTML" },
  { no: 4, name: "OBJECT_TYPE_IMAGE" },
  { no: 5, name: "OBJECT_TYPE_PDF" },
  { no: 6, name: "OBJECT_TYPE_AUDIO" },
  { no: 7, name: "OBJECT_TYPE_SLACK" },
]);

/**
 * @generated from enum index.v1.ObjectStatus
 */
export enum ObjectStatus {
  /**
   * @generated from enum value: OBJECT_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OBJECT_STATUS_QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: OBJECT_STATUS_INDEXING = 2;
   */
  INDEXING = 2,

  /**
   * @generated from enum value: OBJECT_STATUS_READY = 3;
   */
  READY = 3,

  /**
   * @generated from enum value: OBJECT_STATUS_ERROR = 4;
   */
  ERROR = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ObjectStatus)
proto3.util.setEnumType(ObjectStatus, "index.v1.ObjectStatus", [
  { no: 0, name: "OBJECT_STATUS_UNSPECIFIED" },
  { no: 1, name: "OBJECT_STATUS_QUEUED" },
  { no: 2, name: "OBJECT_STATUS_INDEXING" },
  { no: 3, name: "OBJECT_STATUS_READY" },
  { no: 4, name: "OBJECT_STATUS_ERROR" },
]);

/**
 * @generated from message index.v1.UpsertObjectRequest
 */
export class UpsertObjectRequest extends Message<UpsertObjectRequest> {
  /**
   * @generated from field: optional string existing_id = 1;
   */
  existingId?: string;

  /**
   * @generated from field: optional string parent_id = 2;
   */
  parentId?: string;

  /**
   * @generated from field: optional index.v1.ObjectType object_type = 3;
   */
  objectType?: ObjectType;

  /**
   * @generated from field: optional index.v1.ObjectMetadata metadata = 4;
   */
  metadata?: ObjectMetadata;

  /**
   * @generated from field: optional index.v1.Properties properties = 5;
   */
  properties?: Properties;

  /**
   * @generated from field: optional string label = 6;
   */
  label?: string;

  constructor(data?: PartialMessage<UpsertObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.UpsertObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "existing_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "object_type", kind: "enum", T: proto3.getEnumType(ObjectType), opt: true },
    { no: 4, name: "metadata", kind: "message", T: ObjectMetadata, opt: true },
    { no: 5, name: "properties", kind: "message", T: Properties, opt: true },
    { no: 6, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertObjectRequest {
    return new UpsertObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertObjectRequest {
    return new UpsertObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertObjectRequest {
    return new UpsertObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertObjectRequest | PlainMessage<UpsertObjectRequest> | undefined, b: UpsertObjectRequest | PlainMessage<UpsertObjectRequest> | undefined): boolean {
    return proto3.util.equals(UpsertObjectRequest, a, b);
  }
}

/**
 * @generated from message index.v1.UpsertObjectResponse
 */
export class UpsertObjectResponse extends Message<UpsertObjectResponse> {
  /**
   * @generated from field: index.v1.Object object = 1;
   */
  object?: Object$;

  constructor(data?: PartialMessage<UpsertObjectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.UpsertObjectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Object$ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertObjectResponse {
    return new UpsertObjectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertObjectResponse {
    return new UpsertObjectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertObjectResponse {
    return new UpsertObjectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertObjectResponse | PlainMessage<UpsertObjectResponse> | undefined, b: UpsertObjectResponse | PlainMessage<UpsertObjectResponse> | undefined): boolean {
    return proto3.util.equals(UpsertObjectResponse, a, b);
  }
}

/**
 * @generated from message index.v1.ListObjectsRequest
 */
export class ListObjectsRequest extends Message<ListObjectsRequest> {
  /**
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * @generated from field: optional string cursor = 2;
   */
  cursor?: string;

  /**
   * @generated from field: optional int32 limit = 3;
   */
  limit?: number;

  /**
   * If specified, we'll only return objects that have this label.
   * Note: Labels aren't required to be unique, so it is up to the
   * application to account for this.
   *
   * @generated from field: optional string label = 4;
   */
  label?: string;

  constructor(data?: PartialMessage<ListObjectsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.ListObjectsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListObjectsRequest {
    return new ListObjectsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListObjectsRequest {
    return new ListObjectsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListObjectsRequest {
    return new ListObjectsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListObjectsRequest | PlainMessage<ListObjectsRequest> | undefined, b: ListObjectsRequest | PlainMessage<ListObjectsRequest> | undefined): boolean {
    return proto3.util.equals(ListObjectsRequest, a, b);
  }
}

/**
 * @generated from message index.v1.ListObjectsResponse
 */
export class ListObjectsResponse extends Message<ListObjectsResponse> {
  /**
   * @generated from field: repeated index.v1.Object objects = 1;
   */
  objects: Object$[] = [];

  /**
   * @generated from field: optional string next_cursor = 2;
   */
  nextCursor?: string;

  constructor(data?: PartialMessage<ListObjectsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.ListObjectsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects", kind: "message", T: Object$, repeated: true },
    { no: 2, name: "next_cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListObjectsResponse {
    return new ListObjectsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListObjectsResponse {
    return new ListObjectsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListObjectsResponse {
    return new ListObjectsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListObjectsResponse | PlainMessage<ListObjectsResponse> | undefined, b: ListObjectsResponse | PlainMessage<ListObjectsResponse> | undefined): boolean {
    return proto3.util.equals(ListObjectsResponse, a, b);
  }
}

/**
 * @generated from message index.v1.GetObjectsRequest
 */
export class GetObjectsRequest extends Message<GetObjectsRequest> {
  /**
   * @generated from field: repeated string object_ids = 1;
   */
  objectIds: string[] = [];

  constructor(data?: PartialMessage<GetObjectsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.GetObjectsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetObjectsRequest {
    return new GetObjectsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetObjectsRequest {
    return new GetObjectsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetObjectsRequest {
    return new GetObjectsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetObjectsRequest | PlainMessage<GetObjectsRequest> | undefined, b: GetObjectsRequest | PlainMessage<GetObjectsRequest> | undefined): boolean {
    return proto3.util.equals(GetObjectsRequest, a, b);
  }
}

/**
 * @generated from message index.v1.GetObjectsResponse
 */
export class GetObjectsResponse extends Message<GetObjectsResponse> {
  /**
   * @generated from field: map<string, index.v1.Object> objects = 1;
   */
  objects: { [key: string]: Object$ } = {};

  /**
   * @generated from field: repeated string missing = 2;
   */
  missing: string[] = [];

  constructor(data?: PartialMessage<GetObjectsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.GetObjectsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Object$} },
    { no: 2, name: "missing", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetObjectsResponse {
    return new GetObjectsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetObjectsResponse {
    return new GetObjectsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetObjectsResponse {
    return new GetObjectsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetObjectsResponse | PlainMessage<GetObjectsResponse> | undefined, b: GetObjectsResponse | PlainMessage<GetObjectsResponse> | undefined): boolean {
    return proto3.util.equals(GetObjectsResponse, a, b);
  }
}

/**
 * @generated from message index.v1.DeleteObjectRequest
 */
export class DeleteObjectRequest extends Message<DeleteObjectRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.DeleteObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteObjectRequest {
    return new DeleteObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteObjectRequest {
    return new DeleteObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteObjectRequest {
    return new DeleteObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteObjectRequest | PlainMessage<DeleteObjectRequest> | undefined, b: DeleteObjectRequest | PlainMessage<DeleteObjectRequest> | undefined): boolean {
    return proto3.util.equals(DeleteObjectRequest, a, b);
  }
}

/**
 * @generated from message index.v1.DeleteObjectResponse
 */
export class DeleteObjectResponse extends Message<DeleteObjectResponse> {
  /**
   * @generated from field: int32 deleted = 1;
   */
  deleted = 0;

  constructor(data?: PartialMessage<DeleteObjectResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.DeleteObjectResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deleted", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteObjectResponse {
    return new DeleteObjectResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteObjectResponse {
    return new DeleteObjectResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteObjectResponse {
    return new DeleteObjectResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteObjectResponse | PlainMessage<DeleteObjectResponse> | undefined, b: DeleteObjectResponse | PlainMessage<DeleteObjectResponse> | undefined): boolean {
    return proto3.util.equals(DeleteObjectResponse, a, b);
  }
}

/**
 * @generated from message index.v1.BulkDeleteObjectsRequest
 */
export class BulkDeleteObjectsRequest extends Message<BulkDeleteObjectsRequest> {
  /**
   * Only affect objects with this parent.
   * If unspecified, will default to the root, i.e.
   * objects with no parent.
   *
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * Label can be an exact match, or use '%' as a wildcard.
   * For example, 'foo%' will match all labels that start with 'foo'.
   * This is case sensitive.
   *
   * @generated from field: string label = 2;
   */
  label = "";

  constructor(data?: PartialMessage<BulkDeleteObjectsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.BulkDeleteObjectsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkDeleteObjectsRequest {
    return new BulkDeleteObjectsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkDeleteObjectsRequest {
    return new BulkDeleteObjectsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkDeleteObjectsRequest {
    return new BulkDeleteObjectsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BulkDeleteObjectsRequest | PlainMessage<BulkDeleteObjectsRequest> | undefined, b: BulkDeleteObjectsRequest | PlainMessage<BulkDeleteObjectsRequest> | undefined): boolean {
    return proto3.util.equals(BulkDeleteObjectsRequest, a, b);
  }
}

/**
 * @generated from message index.v1.BulkDeleteObjectsResponse
 */
export class BulkDeleteObjectsResponse extends Message<BulkDeleteObjectsResponse> {
  constructor(data?: PartialMessage<BulkDeleteObjectsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.BulkDeleteObjectsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkDeleteObjectsResponse {
    return new BulkDeleteObjectsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkDeleteObjectsResponse {
    return new BulkDeleteObjectsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkDeleteObjectsResponse {
    return new BulkDeleteObjectsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BulkDeleteObjectsResponse | PlainMessage<BulkDeleteObjectsResponse> | undefined, b: BulkDeleteObjectsResponse | PlainMessage<BulkDeleteObjectsResponse> | undefined): boolean {
    return proto3.util.equals(BulkDeleteObjectsResponse, a, b);
  }
}

/**
 * @generated from message index.v1.CountObjectsRequest
 */
export class CountObjectsRequest extends Message<CountObjectsRequest> {
  /**
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * Same behavior as ListObjectsRequest.label.
   *
   * @generated from field: optional string label = 2;
   */
  label?: string;

  constructor(data?: PartialMessage<CountObjectsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.CountObjectsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountObjectsRequest {
    return new CountObjectsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountObjectsRequest {
    return new CountObjectsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountObjectsRequest {
    return new CountObjectsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountObjectsRequest | PlainMessage<CountObjectsRequest> | undefined, b: CountObjectsRequest | PlainMessage<CountObjectsRequest> | undefined): boolean {
    return proto3.util.equals(CountObjectsRequest, a, b);
  }
}

/**
 * @generated from message index.v1.CountObjectsResponse
 */
export class CountObjectsResponse extends Message<CountObjectsResponse> {
  /**
   * @generated from field: int32 count = 1;
   */
  count = 0;

  constructor(data?: PartialMessage<CountObjectsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.CountObjectsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountObjectsResponse {
    return new CountObjectsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountObjectsResponse {
    return new CountObjectsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountObjectsResponse {
    return new CountObjectsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountObjectsResponse | PlainMessage<CountObjectsResponse> | undefined, b: CountObjectsResponse | PlainMessage<CountObjectsResponse> | undefined): boolean {
    return proto3.util.equals(CountObjectsResponse, a, b);
  }
}

/**
 * @generated from message index.v1.WebhookRequest
 */
export class WebhookRequest extends Message<WebhookRequest> {
  /**
   * @generated from field: string object_id = 1;
   */
  objectId = "";

  /**
   * @generated from field: string operation = 2;
   */
  operation = "";

  /**
   * @generated from field: bytes body = 3;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<WebhookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.WebhookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebhookRequest {
    return new WebhookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebhookRequest {
    return new WebhookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebhookRequest {
    return new WebhookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WebhookRequest | PlainMessage<WebhookRequest> | undefined, b: WebhookRequest | PlainMessage<WebhookRequest> | undefined): boolean {
    return proto3.util.equals(WebhookRequest, a, b);
  }
}

/**
 * @generated from message index.v1.WebhookResponse
 */
export class WebhookResponse extends Message<WebhookResponse> {
  /**
   * @generated from field: bytes body = 1;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<WebhookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.WebhookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebhookResponse {
    return new WebhookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebhookResponse {
    return new WebhookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebhookResponse {
    return new WebhookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WebhookResponse | PlainMessage<WebhookResponse> | undefined, b: WebhookResponse | PlainMessage<WebhookResponse> | undefined): boolean {
    return proto3.util.equals(WebhookResponse, a, b);
  }
}

/**
 * @generated from message index.v1.SearchRequest
 */
export class SearchRequest extends Message<SearchRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: repeated string roots = 2;
   */
  roots: string[] = [];

  /**
   * @generated from field: optional string session_id = 3;
   */
  sessionId?: string;

  /**
   * @generated from field: optional index.v1.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * @generated from field: optional int32 limit = 5;
   */
  limit?: number;

  constructor(data?: PartialMessage<SearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.SearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roots", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "session_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "filter", kind: "message", T: Filter, opt: true },
    { no: 5, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest {
    return new SearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRequest | PlainMessage<SearchRequest> | undefined, b: SearchRequest | PlainMessage<SearchRequest> | undefined): boolean {
    return proto3.util.equals(SearchRequest, a, b);
  }
}

/**
 * @generated from message index.v1.SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: string search_id = 1;
   */
  searchId = "";

  /**
   * @generated from field: repeated index.v1.SearchResponse.Match matches = 2;
   */
  matches: SearchResponse_Match[] = [];

  /**
   * @generated from field: map<string, index.v1.Object> objects = 3;
   */
  objects: { [key: string]: Object$ } = {};

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "search_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "matches", kind: "message", T: SearchResponse_Match, repeated: true },
    { no: 3, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Object$} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * @generated from message index.v1.SearchResponse.Match
 */
export class SearchResponse_Match extends Message<SearchResponse_Match> {
  /**
   * @generated from field: string match_id = 1;
   */
  matchId = "";

  /**
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  /**
   * @generated from field: string content = 3;
   */
  content = "";

  /**
   * @generated from field: float score = 4;
   */
  score = 0;

  /**
   * @generated from field: optional index.v1.Properties extra = 5;
   */
  extra?: Properties;

  constructor(data?: PartialMessage<SearchResponse_Match>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.SearchResponse.Match";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "extra", kind: "message", T: Properties, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse_Match {
    return new SearchResponse_Match().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse_Match {
    return new SearchResponse_Match().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse_Match {
    return new SearchResponse_Match().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse_Match | PlainMessage<SearchResponse_Match> | undefined, b: SearchResponse_Match | PlainMessage<SearchResponse_Match> | undefined): boolean {
    return proto3.util.equals(SearchResponse_Match, a, b);
  }
}

/**
 * @generated from message index.v1.AnswerRequest
 */
export class AnswerRequest extends Message<AnswerRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: repeated string roots = 2;
   */
  roots: string[] = [];

  /**
   * @generated from field: optional string session_id = 3;
   */
  sessionId?: string;

  /**
   * @generated from field: optional index.v1.Filter filter = 4;
   */
  filter?: Filter;

  constructor(data?: PartialMessage<AnswerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.AnswerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roots", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "session_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "filter", kind: "message", T: Filter, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerRequest {
    return new AnswerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerRequest {
    return new AnswerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerRequest {
    return new AnswerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerRequest | PlainMessage<AnswerRequest> | undefined, b: AnswerRequest | PlainMessage<AnswerRequest> | undefined): boolean {
    return proto3.util.equals(AnswerRequest, a, b);
  }
}

/**
 * @generated from message index.v1.AnswerResponse
 */
export class AnswerResponse extends Message<AnswerResponse> {
  /**
   * @generated from field: string answer_id = 1;
   */
  answerId = "";

  /**
   * @generated from field: string answer = 2;
   */
  answer = "";

  /**
   * @generated from field: float confidence = 3;
   */
  confidence = 0;

  /**
   * @generated from field: repeated index.v1.Object sources = 4;
   */
  sources: Object$[] = [];

  constructor(data?: PartialMessage<AnswerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.AnswerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "sources", kind: "message", T: Object$, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerResponse {
    return new AnswerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerResponse {
    return new AnswerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerResponse {
    return new AnswerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerResponse | PlainMessage<AnswerResponse> | undefined, b: AnswerResponse | PlainMessage<AnswerResponse> | undefined): boolean {
    return proto3.util.equals(AnswerResponse, a, b);
  }
}

/**
 * @generated from message index.v1.SearchFeedback
 */
export class SearchFeedback extends Message<SearchFeedback> {
  /**
   * @generated from field: string search_id = 1;
   */
  searchId = "";

  /**
   * @generated from field: string clicked_match_id = 2;
   */
  clickedMatchId = "";

  constructor(data?: PartialMessage<SearchFeedback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.SearchFeedback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "search_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "clicked_match_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchFeedback {
    return new SearchFeedback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchFeedback {
    return new SearchFeedback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchFeedback {
    return new SearchFeedback().fromJsonString(jsonString, options);
  }

  static equals(a: SearchFeedback | PlainMessage<SearchFeedback> | undefined, b: SearchFeedback | PlainMessage<SearchFeedback> | undefined): boolean {
    return proto3.util.equals(SearchFeedback, a, b);
  }
}

/**
 * @generated from message index.v1.AnswerFeedback
 */
export class AnswerFeedback extends Message<AnswerFeedback> {
  /**
   * @generated from field: string answer_id = 1;
   */
  answerId = "";

  /**
   * @generated from field: bool positive_reaction = 2;
   */
  positiveReaction = false;

  constructor(data?: PartialMessage<AnswerFeedback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.AnswerFeedback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "positive_reaction", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerFeedback {
    return new AnswerFeedback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerFeedback {
    return new AnswerFeedback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerFeedback {
    return new AnswerFeedback().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerFeedback | PlainMessage<AnswerFeedback> | undefined, b: AnswerFeedback | PlainMessage<AnswerFeedback> | undefined): boolean {
    return proto3.util.equals(AnswerFeedback, a, b);
  }
}

/**
 * @generated from message index.v1.FeedbackRequest
 */
export class FeedbackRequest extends Message<FeedbackRequest> {
  /**
   * @generated from oneof index.v1.FeedbackRequest.feedback
   */
  feedback: {
    /**
     * @generated from field: index.v1.SearchFeedback search = 1;
     */
    value: SearchFeedback;
    case: "search";
  } | {
    /**
     * @generated from field: index.v1.AnswerFeedback answer = 2;
     */
    value: AnswerFeedback;
    case: "answer";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FeedbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.FeedbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "search", kind: "message", T: SearchFeedback, oneof: "feedback" },
    { no: 2, name: "answer", kind: "message", T: AnswerFeedback, oneof: "feedback" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined, b: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined): boolean {
    return proto3.util.equals(FeedbackRequest, a, b);
  }
}

/**
 * @generated from message index.v1.FeedbackResponse
 */
export class FeedbackResponse extends Message<FeedbackResponse> {
  constructor(data?: PartialMessage<FeedbackResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.FeedbackResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined, b: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined): boolean {
    return proto3.util.equals(FeedbackResponse, a, b);
  }
}

/**
 * @generated from message index.v1.ObjectMetadata
 */
export class ObjectMetadata extends Message<ObjectMetadata> {
  /**
   * @generated from oneof index.v1.ObjectMetadata.metadata
   */
  metadata: {
    /**
     * @generated from field: index.v1.CollectionObjectMetadata collection = 1;
     */
    value: CollectionObjectMetadata;
    case: "collection";
  } | {
    /**
     * @generated from field: index.v1.TextObjectMetadata text = 2;
     */
    value: TextObjectMetadata;
    case: "text";
  } | {
    /**
     * @generated from field: index.v1.HTMLObjectMetadata html = 3;
     */
    value: HTMLObjectMetadata;
    case: "html";
  } | {
    /**
     * @generated from field: index.v1.ImageObjectMetadata image = 4;
     */
    value: ImageObjectMetadata;
    case: "image";
  } | {
    /**
     * @generated from field: index.v1.PDFObjectMetadata pdf = 5;
     */
    value: PDFObjectMetadata;
    case: "pdf";
  } | {
    /**
     * @generated from field: index.v1.AudioObjectMetadata audio = 6;
     */
    value: AudioObjectMetadata;
    case: "audio";
  } | {
    /**
     * @generated from field: index.v1.SlackObjectMetadata slack = 7;
     */
    value: SlackObjectMetadata;
    case: "slack";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.ObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection", kind: "message", T: CollectionObjectMetadata, oneof: "metadata" },
    { no: 2, name: "text", kind: "message", T: TextObjectMetadata, oneof: "metadata" },
    { no: 3, name: "html", kind: "message", T: HTMLObjectMetadata, oneof: "metadata" },
    { no: 4, name: "image", kind: "message", T: ImageObjectMetadata, oneof: "metadata" },
    { no: 5, name: "pdf", kind: "message", T: PDFObjectMetadata, oneof: "metadata" },
    { no: 6, name: "audio", kind: "message", T: AudioObjectMetadata, oneof: "metadata" },
    { no: 7, name: "slack", kind: "message", T: SlackObjectMetadata, oneof: "metadata" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectMetadata {
    return new ObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectMetadata | PlainMessage<ObjectMetadata> | undefined, b: ObjectMetadata | PlainMessage<ObjectMetadata> | undefined): boolean {
    return proto3.util.equals(ObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.CollectionObjectMetadata
 */
export class CollectionObjectMetadata extends Message<CollectionObjectMetadata> {
  constructor(data?: PartialMessage<CollectionObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.CollectionObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionObjectMetadata {
    return new CollectionObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionObjectMetadata {
    return new CollectionObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionObjectMetadata {
    return new CollectionObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionObjectMetadata | PlainMessage<CollectionObjectMetadata> | undefined, b: CollectionObjectMetadata | PlainMessage<CollectionObjectMetadata> | undefined): boolean {
    return proto3.util.equals(CollectionObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.TextObjectMetadata
 */
export class TextObjectMetadata extends Message<TextObjectMetadata> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<TextObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.TextObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextObjectMetadata {
    return new TextObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextObjectMetadata {
    return new TextObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextObjectMetadata {
    return new TextObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: TextObjectMetadata | PlainMessage<TextObjectMetadata> | undefined, b: TextObjectMetadata | PlainMessage<TextObjectMetadata> | undefined): boolean {
    return proto3.util.equals(TextObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.HTMLObjectMetadata
 */
export class HTMLObjectMetadata extends Message<HTMLObjectMetadata> {
  /**
   * @generated from field: optional string html = 1;
   */
  html?: string;

  /**
   * @generated from field: optional string url = 2;
   */
  url?: string;

  constructor(data?: PartialMessage<HTMLObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.HTMLObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "html", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTMLObjectMetadata {
    return new HTMLObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTMLObjectMetadata {
    return new HTMLObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTMLObjectMetadata {
    return new HTMLObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: HTMLObjectMetadata | PlainMessage<HTMLObjectMetadata> | undefined, b: HTMLObjectMetadata | PlainMessage<HTMLObjectMetadata> | undefined): boolean {
    return proto3.util.equals(HTMLObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.ImageObjectMetadata
 */
export class ImageObjectMetadata extends Message<ImageObjectMetadata> {
  /**
   * Supports: JPEG/JPG, PNG.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: optional string alt = 2;
   */
  alt?: string;

  constructor(data?: PartialMessage<ImageObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.ImageObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "alt", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageObjectMetadata {
    return new ImageObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageObjectMetadata {
    return new ImageObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageObjectMetadata {
    return new ImageObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ImageObjectMetadata | PlainMessage<ImageObjectMetadata> | undefined, b: ImageObjectMetadata | PlainMessage<ImageObjectMetadata> | undefined): boolean {
    return proto3.util.equals(ImageObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.PDFObjectMetadata
 */
export class PDFObjectMetadata extends Message<PDFObjectMetadata> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<PDFObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.PDFObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PDFObjectMetadata {
    return new PDFObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PDFObjectMetadata {
    return new PDFObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PDFObjectMetadata {
    return new PDFObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PDFObjectMetadata | PlainMessage<PDFObjectMetadata> | undefined, b: PDFObjectMetadata | PlainMessage<PDFObjectMetadata> | undefined): boolean {
    return proto3.util.equals(PDFObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.AudioObjectMetadata
 */
export class AudioObjectMetadata extends Message<AudioObjectMetadata> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<AudioObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.AudioObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioObjectMetadata {
    return new AudioObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioObjectMetadata {
    return new AudioObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioObjectMetadata {
    return new AudioObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AudioObjectMetadata | PlainMessage<AudioObjectMetadata> | undefined, b: AudioObjectMetadata | PlainMessage<AudioObjectMetadata> | undefined): boolean {
    return proto3.util.equals(AudioObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.SlackObjectMetadata
 */
export class SlackObjectMetadata extends Message<SlackObjectMetadata> {
  /**
   * @generated from field: string bot_token = 1;
   */
  botToken = "";

  /**
   * Will be set automatically if omitted.
   *
   * @generated from field: optional string bot_user_id = 2;
   */
  botUserId?: string;

  constructor(data?: PartialMessage<SlackObjectMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.SlackObjectMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bot_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bot_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SlackObjectMetadata {
    return new SlackObjectMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SlackObjectMetadata {
    return new SlackObjectMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SlackObjectMetadata {
    return new SlackObjectMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SlackObjectMetadata | PlainMessage<SlackObjectMetadata> | undefined, b: SlackObjectMetadata | PlainMessage<SlackObjectMetadata> | undefined): boolean {
    return proto3.util.equals(SlackObjectMetadata, a, b);
  }
}

/**
 * @generated from message index.v1.Properties
 */
export class Properties extends Message<Properties> {
  /**
   * @generated from field: map<string, index.v1.Property> properties = 1;
   */
  properties: { [key: string]: Property } = {};

  constructor(data?: PartialMessage<Properties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Properties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Property} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Properties {
    return new Properties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJsonString(jsonString, options);
  }

  static equals(a: Properties | PlainMessage<Properties> | undefined, b: Properties | PlainMessage<Properties> | undefined): boolean {
    return proto3.util.equals(Properties, a, b);
  }
}

/**
 * @generated from message index.v1.TextArray
 */
export class TextArray extends Message<TextArray> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<TextArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.TextArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextArray {
    return new TextArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJsonString(jsonString, options);
  }

  static equals(a: TextArray | PlainMessage<TextArray> | undefined, b: TextArray | PlainMessage<TextArray> | undefined): boolean {
    return proto3.util.equals(TextArray, a, b);
  }
}

/**
 * @generated from message index.v1.NumberArray
 */
export class NumberArray extends Message<NumberArray> {
  /**
   * @generated from field: repeated double values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<NumberArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.NumberArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumberArray {
    return new NumberArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJsonString(jsonString, options);
  }

  static equals(a: NumberArray | PlainMessage<NumberArray> | undefined, b: NumberArray | PlainMessage<NumberArray> | undefined): boolean {
    return proto3.util.equals(NumberArray, a, b);
  }
}

/**
 * @generated from message index.v1.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from oneof index.v1.Property.value
   */
  value: {
    /**
     * @generated from field: string text = 2;
     */
    value: string;
    case: "text";
  } | {
    /**
     * @generated from field: double number = 3;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: index.v1.TextArray text_array = 4;
     */
    value: TextArray;
    case: "textArray";
  } | {
    /**
     * @generated from field: index.v1.NumberArray number_array = 5;
     */
    value: NumberArray;
    case: "numberArray";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 4, name: "text_array", kind: "message", T: TextArray, oneof: "value" },
    { no: 5, name: "number_array", kind: "message", T: NumberArray, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * @generated from message index.v1.KeyedProperty
 */
export class KeyedProperty extends Message<KeyedProperty> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: index.v1.Property property = 2;
   */
  property?: Property;

  constructor(data?: PartialMessage<KeyedProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.KeyedProperty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "property", kind: "message", T: Property },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyedProperty {
    return new KeyedProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyedProperty {
    return new KeyedProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyedProperty {
    return new KeyedProperty().fromJsonString(jsonString, options);
  }

  static equals(a: KeyedProperty | PlainMessage<KeyedProperty> | undefined, b: KeyedProperty | PlainMessage<KeyedProperty> | undefined): boolean {
    return proto3.util.equals(KeyedProperty, a, b);
  }
}

/**
 * @generated from message index.v1.Object
 */
export class Object$ extends Message<Object$> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp updated_at = 3;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: optional string parent_id = 4;
   */
  parentId?: string;

  /**
   * @generated from field: index.v1.ObjectType type = 5;
   */
  type = ObjectType.UNSPECIFIED;

  /**
   * @generated from field: index.v1.ObjectMetadata metadata = 6;
   */
  metadata?: ObjectMetadata;

  /**
   * @generated from field: index.v1.Properties properties = 7;
   */
  properties?: Properties;

  /**
   * @generated from field: index.v1.ObjectStatus status = 8;
   */
  status = ObjectStatus.UNSPECIFIED;

  /**
   * @generated from field: optional string label = 9;
   */
  label?: string;

  constructor(data?: PartialMessage<Object$>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "updated_at", kind: "message", T: Timestamp, opt: true },
    { no: 4, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "type", kind: "enum", T: proto3.getEnumType(ObjectType) },
    { no: 6, name: "metadata", kind: "message", T: ObjectMetadata },
    { no: 7, name: "properties", kind: "message", T: Properties },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(ObjectStatus) },
    { no: 9, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object$ {
    return new Object$().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJsonString(jsonString, options);
  }

  static equals(a: Object$ | PlainMessage<Object$> | undefined, b: Object$ | PlainMessage<Object$> | undefined): boolean {
    return proto3.util.equals(Object$, a, b);
  }
}

/**
 * @generated from message index.v1.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * @generated from field: repeated index.v1.Condition conditions = 1;
   */
  conditions: Condition[] = [];

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: Condition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * @generated from message index.v1.Range
 */
export class Range extends Message<Range> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: optional double lt = 2;
   */
  lt?: number;

  /**
   * @generated from field: optional double lte = 3;
   */
  lte?: number;

  /**
   * @generated from field: optional double gt = 4;
   */
  gt?: number;

  /**
   * @generated from field: optional double gte = 5;
   */
  gte?: number;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "lt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "lte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "gt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 5, name: "gte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * @generated from message index.v1.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * @generated from oneof index.v1.Condition.condition
   */
  condition: {
    /**
     * @generated from field: index.v1.KeyedProperty property = 1;
     */
    value: KeyedProperty;
    case: "property";
  } | {
    /**
     * @generated from field: index.v1.Range range = 2;
     */
    value: Range;
    case: "range";
  } | {
    /**
     * @generated from field: index.v1.Filter and = 3;
     */
    value: Filter;
    case: "and";
  } | {
    /**
     * @generated from field: index.v1.Filter or = 4;
     */
    value: Filter;
    case: "or";
  } | {
    /**
     * @generated from field: index.v1.Filter not = 5;
     */
    value: Filter;
    case: "not";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "index.v1.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: KeyedProperty, oneof: "condition" },
    { no: 2, name: "range", kind: "message", T: Range, oneof: "condition" },
    { no: 3, name: "and", kind: "message", T: Filter, oneof: "condition" },
    { no: 4, name: "or", kind: "message", T: Filter, oneof: "condition" },
    { no: 5, name: "not", kind: "message", T: Filter, oneof: "condition" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

