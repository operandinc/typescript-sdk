// @generated by protoc-gen-es v1.0.0 with parameter "target=ts+js"
// @generated from file file/v1/file.proto (package file.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { GroupProfile, UserProfile } from "../../tenant/v1/tenant_pb.js";

/**
 * SharingRole is the role of a user in a shared file.
 *
 * @generated from enum file.v1.SharingRole
 */
export enum SharingRole {
  /**
   * @generated from enum value: SHARING_ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SHARING_ROLE_OWNER = 1;
   */
  OWNER = 1,

  /**
   * @generated from enum value: SHARING_ROLE_EDITOR = 2;
   */
  EDITOR = 2,

  /**
   * @generated from enum value: SHARING_ROLE_VIEWER = 3;
   */
  VIEWER = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SharingRole)
proto3.util.setEnumType(SharingRole, "file.v1.SharingRole", [
  { no: 0, name: "SHARING_ROLE_UNSPECIFIED" },
  { no: 1, name: "SHARING_ROLE_OWNER" },
  { no: 2, name: "SHARING_ROLE_EDITOR" },
  { no: 3, name: "SHARING_ROLE_VIEWER" },
]);

/**
 * SyncKind is an enumeration over the various supported syncs.
 *
 * @generated from enum file.v1.SyncKind
 */
export enum SyncKind {
  /**
   * @generated from enum value: SYNC_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SYNC_KIND_SITEMAP = 1;
   */
  SITEMAP = 1,

  /**
   * @generated from enum value: SYNC_KIND_RSS = 2;
   */
  RSS = 2,

  /**
   * @generated from enum value: SYNC_KIND_SLACK = 3;
   */
  SLACK = 3,

  /**
   * @generated from enum value: SYNC_KIND_GITHUB_REPOSITORY = 4;
   */
  GITHUB_REPOSITORY = 4,

  /**
   * @generated from enum value: SYNC_KIND_NOTION = 5;
   */
  NOTION = 5,

  /**
   * @generated from enum value: SYNC_KIND_DISCORD = 6;
   */
  DISCORD = 6,

  /**
   * @generated from enum value: SYNC_KIND_LINEAR = 7;
   */
  LINEAR = 7,

  /**
   * @generated from enum value: SYNC_KIND_MEETING_BOT = 8;
   */
  MEETING_BOT = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(SyncKind)
proto3.util.setEnumType(SyncKind, "file.v1.SyncKind", [
  { no: 0, name: "SYNC_KIND_UNSPECIFIED" },
  { no: 1, name: "SYNC_KIND_SITEMAP" },
  { no: 2, name: "SYNC_KIND_RSS" },
  { no: 3, name: "SYNC_KIND_SLACK" },
  { no: 4, name: "SYNC_KIND_GITHUB_REPOSITORY" },
  { no: 5, name: "SYNC_KIND_NOTION" },
  { no: 6, name: "SYNC_KIND_DISCORD" },
  { no: 7, name: "SYNC_KIND_LINEAR" },
  { no: 8, name: "SYNC_KIND_MEETING_BOT" },
]);

/**
 * IndexingStatus is the status of a file's indexing.
 * If ready, the file's contents will show up in search results.
 *
 * @generated from enum file.v1.IndexingStatus
 */
export enum IndexingStatus {
  /**
   * @generated from enum value: INDEXING_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: INDEXING_STATUS_QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: INDEXING_STATUS_INDEXING = 2;
   */
  INDEXING = 2,

  /**
   * @generated from enum value: INDEXING_STATUS_READY = 3;
   */
  READY = 3,

  /**
   * @generated from enum value: INDEXING_STATUS_FAILED = 4;
   */
  FAILED = 4,

  /**
   * @generated from enum value: INDEXING_STATUS_UNSUPPORTED = 5;
   */
  UNSUPPORTED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(IndexingStatus)
proto3.util.setEnumType(IndexingStatus, "file.v1.IndexingStatus", [
  { no: 0, name: "INDEXING_STATUS_UNSPECIFIED" },
  { no: 1, name: "INDEXING_STATUS_QUEUED" },
  { no: 2, name: "INDEXING_STATUS_INDEXING" },
  { no: 3, name: "INDEXING_STATUS_READY" },
  { no: 4, name: "INDEXING_STATUS_FAILED" },
  { no: 5, name: "INDEXING_STATUS_UNSUPPORTED" },
]);

/**
 * PaginationRequest contains generic pagination request information.
 *
 * @generated from message file.v1.PaginationRequest
 */
export class PaginationRequest extends Message<PaginationRequest> {
  /**
   * @generated from field: optional string cursor = 1;
   */
  cursor?: string;

  /**
   * @generated from field: optional int32 page_size = 2;
   */
  pageSize?: number;

  constructor(data?: PartialMessage<PaginationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.PaginationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationRequest {
    return new PaginationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationRequest {
    return new PaginationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationRequest {
    return new PaginationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationRequest | PlainMessage<PaginationRequest> | undefined, b: PaginationRequest | PlainMessage<PaginationRequest> | undefined): boolean {
    return proto3.util.equals(PaginationRequest, a, b);
  }
}

/**
 * PaginationResponse contains generic pagination response information.
 *
 * @generated from message file.v1.PaginationResponse
 */
export class PaginationResponse extends Message<PaginationResponse> {
  /**
   * @generated from field: optional string next_cursor = 1;
   */
  nextCursor?: string;

  constructor(data?: PartialMessage<PaginationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.PaginationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_cursor", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationResponse {
    return new PaginationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationResponse {
    return new PaginationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationResponse {
    return new PaginationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationResponse | PlainMessage<PaginationResponse> | undefined, b: PaginationResponse | PlainMessage<PaginationResponse> | undefined): boolean {
    return proto3.util.equals(PaginationResponse, a, b);
  }
}

/**
 * ReturnedFileOptions contains options for the returned file object (i.e. in the response).
 *
 * @generated from message file.v1.ReturnedFileOptions
 */
export class ReturnedFileOptions extends Message<ReturnedFileOptions> {
  /**
   * Whether to include all parents of the file in the response.
   *
   * @generated from field: bool include_parents = 1;
   */
  includeParents = false;

  constructor(data?: PartialMessage<ReturnedFileOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ReturnedFileOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include_parents", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReturnedFileOptions {
    return new ReturnedFileOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReturnedFileOptions {
    return new ReturnedFileOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReturnedFileOptions {
    return new ReturnedFileOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ReturnedFileOptions | PlainMessage<ReturnedFileOptions> | undefined, b: ReturnedFileOptions | PlainMessage<ReturnedFileOptions> | undefined): boolean {
    return proto3.util.equals(ReturnedFileOptions, a, b);
  }
}

/**
 * FileSelector selects a file by ID or path.
 *
 * @generated from message file.v1.FileSelector
 */
export class FileSelector extends Message<FileSelector> {
  /**
   * @generated from oneof file.v1.FileSelector.selector
   */
  selector: {
    /**
     * @generated from field: string id = 1;
     */
    value: string;
    case: "id";
  } | {
    /**
     * @generated from field: file.v1.FileSelector.ByName by_name = 2;
     */
    value: FileSelector_ByName;
    case: "byName";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FileSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.FileSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "selector" },
    { no: 2, name: "by_name", kind: "message", T: FileSelector_ByName, oneof: "selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileSelector {
    return new FileSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileSelector {
    return new FileSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileSelector {
    return new FileSelector().fromJsonString(jsonString, options);
  }

  static equals(a: FileSelector | PlainMessage<FileSelector> | undefined, b: FileSelector | PlainMessage<FileSelector> | undefined): boolean {
    return proto3.util.equals(FileSelector, a, b);
  }
}

/**
 * @generated from message file.v1.FileSelector.ByName
 */
export class FileSelector_ByName extends Message<FileSelector_ByName> {
  /**
   * Defaults to root if empty or null.
   *
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<FileSelector_ByName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.FileSelector.ByName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileSelector_ByName {
    return new FileSelector_ByName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileSelector_ByName {
    return new FileSelector_ByName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileSelector_ByName {
    return new FileSelector_ByName().fromJsonString(jsonString, options);
  }

  static equals(a: FileSelector_ByName | PlainMessage<FileSelector_ByName> | undefined, b: FileSelector_ByName | PlainMessage<FileSelector_ByName> | undefined): boolean {
    return proto3.util.equals(FileSelector_ByName, a, b);
  }
}

/**
 * GetFileRequest requests a specific file by ID.
 *
 * @generated from message file.v1.GetFileRequest
 */
export class GetFileRequest extends Message<GetFileRequest> {
  /**
   * @generated from field: file.v1.FileSelector selector = 1;
   */
  selector?: FileSelector;

  /**
   * @generated from field: optional file.v1.ReturnedFileOptions return_options = 2;
   */
  returnOptions?: ReturnedFileOptions;

  constructor(data?: PartialMessage<GetFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.GetFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "message", T: FileSelector },
    { no: 2, name: "return_options", kind: "message", T: ReturnedFileOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFileRequest {
    return new GetFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFileRequest {
    return new GetFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFileRequest {
    return new GetFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetFileRequest | PlainMessage<GetFileRequest> | undefined, b: GetFileRequest | PlainMessage<GetFileRequest> | undefined): boolean {
    return proto3.util.equals(GetFileRequest, a, b);
  }
}

/**
 * GetFileResponse returns a file.
 *
 * @generated from message file.v1.GetFileResponse
 */
export class GetFileResponse extends Message<GetFileResponse> {
  /**
   * @generated from field: file.v1.File file = 1;
   */
  file?: File;

  constructor(data?: PartialMessage<GetFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.GetFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFileResponse {
    return new GetFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFileResponse {
    return new GetFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFileResponse {
    return new GetFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetFileResponse | PlainMessage<GetFileResponse> | undefined, b: GetFileResponse | PlainMessage<GetFileResponse> | undefined): boolean {
    return proto3.util.equals(GetFileResponse, a, b);
  }
}

/**
 * FileFilter contains filters for listing files.
 *
 * @generated from message file.v1.FileFilter
 */
export class FileFilter extends Message<FileFilter> {
  /**
   * The parent ID to filter by. If null, all files are returned (from all directories).
   * If empty, only root files are returned. If non-empty, only files in the specified
   * directory are returned.
   *
   * @generated from field: optional string parent_id = 1;
   */
  parentId?: string;

  /**
   * Only show favorite files and folders.
   *
   * @generated from field: optional bool favorite = 2;
   */
  favorite?: boolean;

  /**
   * Only show files shared with the current user (i.e. that you don't own).
   *
   * @generated from field: optional bool shared = 3;
   */
  shared?: boolean;

  constructor(data?: PartialMessage<FileFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.FileFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "favorite", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "shared", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileFilter {
    return new FileFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileFilter {
    return new FileFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileFilter {
    return new FileFilter().fromJsonString(jsonString, options);
  }

  static equals(a: FileFilter | PlainMessage<FileFilter> | undefined, b: FileFilter | PlainMessage<FileFilter> | undefined): boolean {
    return proto3.util.equals(FileFilter, a, b);
  }
}

/**
 * ListFilesRequest requests a list of files.
 * Files will be returned in descending order of last updated time.
 *
 * @generated from message file.v1.ListFilesRequest
 */
export class ListFilesRequest extends Message<ListFilesRequest> {
  /**
   * @generated from field: optional file.v1.FileFilter filter = 1;
   */
  filter?: FileFilter;

  /**
   * @generated from field: optional file.v1.PaginationRequest pagination = 2;
   */
  pagination?: PaginationRequest;

  /**
   * @generated from field: optional file.v1.ReturnedFileOptions return_options = 3;
   */
  returnOptions?: ReturnedFileOptions;

  constructor(data?: PartialMessage<ListFilesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ListFilesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: FileFilter, opt: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationRequest, opt: true },
    { no: 3, name: "return_options", kind: "message", T: ReturnedFileOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFilesRequest {
    return new ListFilesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFilesRequest {
    return new ListFilesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFilesRequest {
    return new ListFilesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListFilesRequest | PlainMessage<ListFilesRequest> | undefined, b: ListFilesRequest | PlainMessage<ListFilesRequest> | undefined): boolean {
    return proto3.util.equals(ListFilesRequest, a, b);
  }
}

/**
 * ListFilesResponse returns a list of files.
 *
 * @generated from message file.v1.ListFilesResponse
 */
export class ListFilesResponse extends Message<ListFilesResponse> {
  /**
   * @generated from field: repeated file.v1.File files = 1;
   */
  files: File[] = [];

  /**
   * @generated from field: file.v1.PaginationResponse pagination = 2;
   */
  pagination?: PaginationResponse;

  constructor(data?: PartialMessage<ListFilesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ListFilesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "files", kind: "message", T: File, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFilesResponse {
    return new ListFilesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFilesResponse {
    return new ListFilesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFilesResponse {
    return new ListFilesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListFilesResponse | PlainMessage<ListFilesResponse> | undefined, b: ListFilesResponse | PlainMessage<ListFilesResponse> | undefined): boolean {
    return proto3.util.equals(ListFilesResponse, a, b);
  }
}

/**
 * CreateFileMeta contains metadata for a file. Must be passed
 * at least once during a CreateFileRequest client stream, and
 * the handler will ignore previous CreateFileMeta messages.
 *
 * @generated from message file.v1.CreateFileMeta
 */
export class CreateFileMeta extends Message<CreateFileMeta> {
  /**
   * Can be empty for root.
   *
   * @generated from field: string parent_id = 1;
   */
  parentId = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: optional file.v1.Properties properties = 3;
   */
  properties?: Properties;

  constructor(data?: PartialMessage<CreateFileMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.CreateFileMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "properties", kind: "message", T: Properties, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateFileMeta {
    return new CreateFileMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateFileMeta {
    return new CreateFileMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateFileMeta {
    return new CreateFileMeta().fromJsonString(jsonString, options);
  }

  static equals(a: CreateFileMeta | PlainMessage<CreateFileMeta> | undefined, b: CreateFileMeta | PlainMessage<CreateFileMeta> | undefined): boolean {
    return proto3.util.equals(CreateFileMeta, a, b);
  }
}

/**
 * CreateFileRequest creates a new file.
 *
 * @generated from message file.v1.CreateFileRequest
 */
export class CreateFileRequest extends Message<CreateFileRequest> {
  /**
   * @generated from field: optional file.v1.CreateFileMeta meta = 1;
   */
  meta?: CreateFileMeta;

  /**
   * @generated from field: bytes data_chunk = 2;
   */
  dataChunk = new Uint8Array(0);

  /**
   * @generated from field: optional file.v1.ReturnedFileOptions return_options = 3;
   */
  returnOptions?: ReturnedFileOptions;

  constructor(data?: PartialMessage<CreateFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.CreateFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: CreateFileMeta, opt: true },
    { no: 2, name: "data_chunk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "return_options", kind: "message", T: ReturnedFileOptions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateFileRequest {
    return new CreateFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateFileRequest {
    return new CreateFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateFileRequest {
    return new CreateFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateFileRequest | PlainMessage<CreateFileRequest> | undefined, b: CreateFileRequest | PlainMessage<CreateFileRequest> | undefined): boolean {
    return proto3.util.equals(CreateFileRequest, a, b);
  }
}

/**
 * CreateFileResponse returns a file.
 *
 * @generated from message file.v1.CreateFileResponse
 */
export class CreateFileResponse extends Message<CreateFileResponse> {
  /**
   * @generated from field: file.v1.File file = 1;
   */
  file?: File;

  constructor(data?: PartialMessage<CreateFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.CreateFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateFileResponse {
    return new CreateFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateFileResponse {
    return new CreateFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateFileResponse {
    return new CreateFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateFileResponse | PlainMessage<CreateFileResponse> | undefined, b: CreateFileResponse | PlainMessage<CreateFileResponse> | undefined): boolean {
    return proto3.util.equals(CreateFileResponse, a, b);
  }
}

/**
 * ImportFromURLRequest imports a file from a URL. The caller is required
 * to pass the URL itself, and an optional parent ID (i.e. where the file
 * will be stored).
 *
 * @generated from message file.v1.ImportFromURLRequest
 */
export class ImportFromURLRequest extends Message<ImportFromURLRequest> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * If unspecified or empty, the file will be stored in the root.
   *
   * @generated from field: optional string parent_id = 2;
   */
  parentId?: string;

  /**
   * If unspecified or empty, the file's name will be derived from the URL.
   *
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * @generated from field: optional file.v1.ReturnedFileOptions return_options = 4;
   */
  returnOptions?: ReturnedFileOptions;

  /**
   * If true, we'll try and be clever when importing the file.
   * For example, if we can find a sitemap on the page, we'll create
   * a smart folder which will sync data with the sitemap periodically.
   * By default, we just fetch the underlying file that the URL points to.
   *
   * @generated from field: optional bool smart = 5;
   */
  smart?: boolean;

  constructor(data?: PartialMessage<ImportFromURLRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ImportFromURLRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "return_options", kind: "message", T: ReturnedFileOptions, opt: true },
    { no: 5, name: "smart", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportFromURLRequest {
    return new ImportFromURLRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportFromURLRequest {
    return new ImportFromURLRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportFromURLRequest {
    return new ImportFromURLRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportFromURLRequest | PlainMessage<ImportFromURLRequest> | undefined, b: ImportFromURLRequest | PlainMessage<ImportFromURLRequest> | undefined): boolean {
    return proto3.util.equals(ImportFromURLRequest, a, b);
  }
}

/**
 * ImportFromURLResponse returns a handle to the file. Note, the file
 * may be in a pending state (i.e. named *.odl) until the import is complete.
 *
 * @generated from message file.v1.ImportFromURLResponse
 */
export class ImportFromURLResponse extends Message<ImportFromURLResponse> {
  /**
   * @generated from field: file.v1.File file = 1;
   */
  file?: File;

  constructor(data?: PartialMessage<ImportFromURLResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ImportFromURLResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportFromURLResponse {
    return new ImportFromURLResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportFromURLResponse {
    return new ImportFromURLResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportFromURLResponse {
    return new ImportFromURLResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportFromURLResponse | PlainMessage<ImportFromURLResponse> | undefined, b: ImportFromURLResponse | PlainMessage<ImportFromURLResponse> | undefined): boolean {
    return proto3.util.equals(ImportFromURLResponse, a, b);
  }
}

/**
 * DeleteFileRequest deletes a file.
 * Note: If the file is a shared directory that you don't own,
 * deleting the file will "unsubscribe" you from the directory.
 *
 * @generated from message file.v1.DeleteFileRequest
 */
export class DeleteFileRequest extends Message<DeleteFileRequest> {
  /**
   * @generated from field: file.v1.FileSelector selector = 1;
   */
  selector?: FileSelector;

  constructor(data?: PartialMessage<DeleteFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.DeleteFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "message", T: FileSelector },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteFileRequest {
    return new DeleteFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteFileRequest {
    return new DeleteFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteFileRequest {
    return new DeleteFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteFileRequest | PlainMessage<DeleteFileRequest> | undefined, b: DeleteFileRequest | PlainMessage<DeleteFileRequest> | undefined): boolean {
    return proto3.util.equals(DeleteFileRequest, a, b);
  }
}

/**
 * DeleteFileResponse returns a file.
 *
 * @generated from message file.v1.DeleteFileResponse
 */
export class DeleteFileResponse extends Message<DeleteFileResponse> {
  constructor(data?: PartialMessage<DeleteFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.DeleteFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteFileResponse {
    return new DeleteFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteFileResponse {
    return new DeleteFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteFileResponse {
    return new DeleteFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteFileResponse | PlainMessage<DeleteFileResponse> | undefined, b: DeleteFileResponse | PlainMessage<DeleteFileResponse> | undefined): boolean {
    return proto3.util.equals(DeleteFileResponse, a, b);
  }
}

/**
 * UpdateFileRequest updates a file.
 *
 * @generated from message file.v1.UpdateFileRequest
 */
export class UpdateFileRequest extends Message<UpdateFileRequest> {
  /**
   * @generated from field: file.v1.FileSelector selector = 1;
   */
  selector?: FileSelector;

  /**
   * @generated from field: optional file.v1.ReturnedFileOptions return_options = 2;
   */
  returnOptions?: ReturnedFileOptions;

  /**
   * @generated from field: optional string parent_id = 3;
   */
  parentId?: string;

  /**
   * @generated from field: optional string name = 4;
   */
  name?: string;

  /**
   * @generated from field: optional bool favorite = 5;
   */
  favorite?: boolean;

  constructor(data?: PartialMessage<UpdateFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.UpdateFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "message", T: FileSelector },
    { no: 2, name: "return_options", kind: "message", T: ReturnedFileOptions, opt: true },
    { no: 3, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "favorite", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateFileRequest | PlainMessage<UpdateFileRequest> | undefined, b: UpdateFileRequest | PlainMessage<UpdateFileRequest> | undefined): boolean {
    return proto3.util.equals(UpdateFileRequest, a, b);
  }
}

/**
 * UpdateFileResponse returns a file.
 *
 * @generated from message file.v1.UpdateFileResponse
 */
export class UpdateFileResponse extends Message<UpdateFileResponse> {
  /**
   * @generated from field: file.v1.File file = 1;
   */
  file?: File;

  constructor(data?: PartialMessage<UpdateFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.UpdateFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateFileResponse | PlainMessage<UpdateFileResponse> | undefined, b: UpdateFileResponse | PlainMessage<UpdateFileResponse> | undefined): boolean {
    return proto3.util.equals(UpdateFileResponse, a, b);
  }
}

/**
 * ShareFileRequest shares a file with another user.
 *
 * @generated from message file.v1.ShareFileRequest
 */
export class ShareFileRequest extends Message<ShareFileRequest> {
  /**
   * @generated from field: file.v1.FileSelector selector = 1;
   */
  selector?: FileSelector;

  /**
   * Cannot be OWNER.
   *
   * @generated from field: file.v1.SharingRole role = 2;
   */
  role = SharingRole.UNSPECIFIED;

  /**
   * @generated from oneof file.v1.ShareFileRequest.target
   */
  target: {
    /**
     * @generated from field: string email = 3;
     */
    value: string;
    case: "email";
  } | {
    /**
     * @generated from field: string group_id = 4;
     */
    value: string;
    case: "groupId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ShareFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ShareFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "message", T: FileSelector },
    { no: 2, name: "role", kind: "enum", T: proto3.getEnumType(SharingRole) },
    { no: 3, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "target" },
    { no: 4, name: "group_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "target" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShareFileRequest {
    return new ShareFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShareFileRequest {
    return new ShareFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShareFileRequest {
    return new ShareFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ShareFileRequest | PlainMessage<ShareFileRequest> | undefined, b: ShareFileRequest | PlainMessage<ShareFileRequest> | undefined): boolean {
    return proto3.util.equals(ShareFileRequest, a, b);
  }
}

/**
 * ShareFileResponse is the response to a ShareFileRequest.
 *
 * @generated from message file.v1.ShareFileResponse
 */
export class ShareFileResponse extends Message<ShareFileResponse> {
  /**
   * @generated from field: string file_id = 1;
   */
  fileId = "";

  /**
   * @generated from field: file.v1.SharedWith shared_with = 2;
   */
  sharedWith?: SharedWith;

  constructor(data?: PartialMessage<ShareFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.ShareFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shared_with", kind: "message", T: SharedWith },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShareFileResponse {
    return new ShareFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShareFileResponse {
    return new ShareFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShareFileResponse {
    return new ShareFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ShareFileResponse | PlainMessage<ShareFileResponse> | undefined, b: ShareFileResponse | PlainMessage<ShareFileResponse> | undefined): boolean {
    return proto3.util.equals(ShareFileResponse, a, b);
  }
}

/**
 * UnshareFileRequest deletes an existing share of a file with another user.
 *
 * @generated from message file.v1.UnshareFileRequest
 */
export class UnshareFileRequest extends Message<UnshareFileRequest> {
  /**
   * @generated from field: string share_id = 1;
   */
  shareId = "";

  constructor(data?: PartialMessage<UnshareFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.UnshareFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "share_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnshareFileRequest {
    return new UnshareFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnshareFileRequest {
    return new UnshareFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnshareFileRequest {
    return new UnshareFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnshareFileRequest | PlainMessage<UnshareFileRequest> | undefined, b: UnshareFileRequest | PlainMessage<UnshareFileRequest> | undefined): boolean {
    return proto3.util.equals(UnshareFileRequest, a, b);
  }
}

/**
 * UnshareFileResponse is the response to a UnshareFileRequest.
 *
 * @generated from message file.v1.UnshareFileResponse
 */
export class UnshareFileResponse extends Message<UnshareFileResponse> {
  constructor(data?: PartialMessage<UnshareFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.UnshareFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnshareFileResponse {
    return new UnshareFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnshareFileResponse {
    return new UnshareFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnshareFileResponse {
    return new UnshareFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnshareFileResponse | PlainMessage<UnshareFileResponse> | undefined, b: UnshareFileResponse | PlainMessage<UnshareFileResponse> | undefined): boolean {
    return proto3.util.equals(UnshareFileResponse, a, b);
  }
}

/**
 * SitemapParams contains parameters for a sitemap sync.
 *
 * @generated from message file.v1.SitemapParams
 */
export class SitemapParams extends Message<SitemapParams> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<SitemapParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.SitemapParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SitemapParams {
    return new SitemapParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SitemapParams {
    return new SitemapParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SitemapParams {
    return new SitemapParams().fromJsonString(jsonString, options);
  }

  static equals(a: SitemapParams | PlainMessage<SitemapParams> | undefined, b: SitemapParams | PlainMessage<SitemapParams> | undefined): boolean {
    return proto3.util.equals(SitemapParams, a, b);
  }
}

/**
 * RSSParams contains parameters for an RSS sync.
 *
 * @generated from message file.v1.RSSParams
 */
export class RSSParams extends Message<RSSParams> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<RSSParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.RSSParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RSSParams {
    return new RSSParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RSSParams {
    return new RSSParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RSSParams {
    return new RSSParams().fromJsonString(jsonString, options);
  }

  static equals(a: RSSParams | PlainMessage<RSSParams> | undefined, b: RSSParams | PlainMessage<RSSParams> | undefined): boolean {
    return proto3.util.equals(RSSParams, a, b);
  }
}

/**
 * SlackParams contains parameters for a Slack sync.
 *
 * @generated from message file.v1.SlackParams
 */
export class SlackParams extends Message<SlackParams> {
  /**
   * Obtained via OAuth flow.
   *
   * @generated from field: string bot_token = 1;
   */
  botToken = "";

  constructor(data?: PartialMessage<SlackParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.SlackParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bot_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SlackParams {
    return new SlackParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SlackParams {
    return new SlackParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SlackParams {
    return new SlackParams().fromJsonString(jsonString, options);
  }

  static equals(a: SlackParams | PlainMessage<SlackParams> | undefined, b: SlackParams | PlainMessage<SlackParams> | undefined): boolean {
    return proto3.util.equals(SlackParams, a, b);
  }
}

/**
 * GithubRepositoryParams contains parameters for a Github repository sync.
 *
 * @generated from message file.v1.GithubRepositoryParams
 */
export class GithubRepositoryParams extends Message<GithubRepositoryParams> {
  /**
   * @generated from field: string owner = 1;
   */
  owner = "";

  /**
   * @generated from field: string repo = 2;
   */
  repo = "";

  /**
   * @generated from oneof file.v1.GithubRepositoryParams.auth
   */
  auth: {
    /**
     * @generated from field: string access_token = 3;
     */
    value: string;
    case: "accessToken";
  } | {
    /**
     * @generated from field: string source_user_id = 4;
     */
    value: string;
    case: "sourceUserId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GithubRepositoryParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.GithubRepositoryParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "repo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "auth" },
    { no: 4, name: "source_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "auth" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubRepositoryParams {
    return new GithubRepositoryParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubRepositoryParams {
    return new GithubRepositoryParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubRepositoryParams {
    return new GithubRepositoryParams().fromJsonString(jsonString, options);
  }

  static equals(a: GithubRepositoryParams | PlainMessage<GithubRepositoryParams> | undefined, b: GithubRepositoryParams | PlainMessage<GithubRepositoryParams> | undefined): boolean {
    return proto3.util.equals(GithubRepositoryParams, a, b);
  }
}

/**
 * NotionParams contains parameters for a Notion sync.
 *
 * @generated from message file.v1.NotionParams
 */
export class NotionParams extends Message<NotionParams> {
  /**
   * Obtained via OAuth flow.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<NotionParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.NotionParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotionParams {
    return new NotionParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotionParams {
    return new NotionParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotionParams {
    return new NotionParams().fromJsonString(jsonString, options);
  }

  static equals(a: NotionParams | PlainMessage<NotionParams> | undefined, b: NotionParams | PlainMessage<NotionParams> | undefined): boolean {
    return proto3.util.equals(NotionParams, a, b);
  }
}

/**
 * DiscordParams contains parameters for a Discord sync.
 *
 * @generated from message file.v1.DiscordParams
 */
export class DiscordParams extends Message<DiscordParams> {
  /**
   * @generated from field: string guild_id = 1;
   */
  guildId = "";

  constructor(data?: PartialMessage<DiscordParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.DiscordParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "guild_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscordParams {
    return new DiscordParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscordParams {
    return new DiscordParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscordParams {
    return new DiscordParams().fromJsonString(jsonString, options);
  }

  static equals(a: DiscordParams | PlainMessage<DiscordParams> | undefined, b: DiscordParams | PlainMessage<DiscordParams> | undefined): boolean {
    return proto3.util.equals(DiscordParams, a, b);
  }
}

/**
 * LinearParams contains parameters for a Linear sync.
 *
 * @generated from message file.v1.LinearParams
 */
export class LinearParams extends Message<LinearParams> {
  /**
   * Obtained via OAuth flow.
   *
   * @generated from field: string access_token = 1;
   */
  accessToken = "";

  constructor(data?: PartialMessage<LinearParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.LinearParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinearParams {
    return new LinearParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinearParams {
    return new LinearParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinearParams {
    return new LinearParams().fromJsonString(jsonString, options);
  }

  static equals(a: LinearParams | PlainMessage<LinearParams> | undefined, b: LinearParams | PlainMessage<LinearParams> | undefined): boolean {
    return proto3.util.equals(LinearParams, a, b);
  }
}

/**
 * MeetingBotParams contains parameters for a Meeting Bot sync.
 *
 * todo
 *
 * @generated from message file.v1.MeetingBotParams
 */
export class MeetingBotParams extends Message<MeetingBotParams> {
  constructor(data?: PartialMessage<MeetingBotParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.MeetingBotParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeetingBotParams {
    return new MeetingBotParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeetingBotParams {
    return new MeetingBotParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeetingBotParams {
    return new MeetingBotParams().fromJsonString(jsonString, options);
  }

  static equals(a: MeetingBotParams | PlainMessage<MeetingBotParams> | undefined, b: MeetingBotParams | PlainMessage<MeetingBotParams> | undefined): boolean {
    return proto3.util.equals(MeetingBotParams, a, b);
  }
}

/**
 * SyncParams contains parameters for a Sync.
 *
 * @generated from message file.v1.SyncParams
 */
export class SyncParams extends Message<SyncParams> {
  /**
   * @generated from oneof file.v1.SyncParams.params
   */
  params: {
    /**
     * @generated from field: file.v1.SitemapParams sitemap = 1;
     */
    value: SitemapParams;
    case: "sitemap";
  } | {
    /**
     * @generated from field: file.v1.RSSParams rss = 2;
     */
    value: RSSParams;
    case: "rss";
  } | {
    /**
     * @generated from field: file.v1.SlackParams slack = 3;
     */
    value: SlackParams;
    case: "slack";
  } | {
    /**
     * @generated from field: file.v1.GithubRepositoryParams github_repository = 4;
     */
    value: GithubRepositoryParams;
    case: "githubRepository";
  } | {
    /**
     * @generated from field: file.v1.NotionParams notion = 5;
     */
    value: NotionParams;
    case: "notion";
  } | {
    /**
     * @generated from field: file.v1.DiscordParams discord = 6;
     */
    value: DiscordParams;
    case: "discord";
  } | {
    /**
     * @generated from field: file.v1.LinearParams linear = 7;
     */
    value: LinearParams;
    case: "linear";
  } | {
    /**
     * @generated from field: file.v1.MeetingBotParams meeting_bot = 8;
     */
    value: MeetingBotParams;
    case: "meetingBot";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SyncParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.SyncParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sitemap", kind: "message", T: SitemapParams, oneof: "params" },
    { no: 2, name: "rss", kind: "message", T: RSSParams, oneof: "params" },
    { no: 3, name: "slack", kind: "message", T: SlackParams, oneof: "params" },
    { no: 4, name: "github_repository", kind: "message", T: GithubRepositoryParams, oneof: "params" },
    { no: 5, name: "notion", kind: "message", T: NotionParams, oneof: "params" },
    { no: 6, name: "discord", kind: "message", T: DiscordParams, oneof: "params" },
    { no: 7, name: "linear", kind: "message", T: LinearParams, oneof: "params" },
    { no: 8, name: "meeting_bot", kind: "message", T: MeetingBotParams, oneof: "params" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncParams {
    return new SyncParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncParams {
    return new SyncParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncParams {
    return new SyncParams().fromJsonString(jsonString, options);
  }

  static equals(a: SyncParams | PlainMessage<SyncParams> | undefined, b: SyncParams | PlainMessage<SyncParams> | undefined): boolean {
    return proto3.util.equals(SyncParams, a, b);
  }
}

/**
 * AttachSyncRequest attaches an Sync to a file.
 *
 * @generated from message file.v1.AttachSyncRequest
 */
export class AttachSyncRequest extends Message<AttachSyncRequest> {
  /**
   * Must be a folder.
   *
   * @generated from field: file.v1.FileSelector selector = 1;
   */
  selector?: FileSelector;

  /**
   * @generated from field: file.v1.SyncKind kind = 2;
   */
  kind = SyncKind.UNSPECIFIED;

  /**
   * @generated from field: file.v1.SyncParams params = 3;
   */
  params?: SyncParams;

  constructor(data?: PartialMessage<AttachSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.AttachSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "message", T: FileSelector },
    { no: 2, name: "kind", kind: "enum", T: proto3.getEnumType(SyncKind) },
    { no: 3, name: "params", kind: "message", T: SyncParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachSyncRequest {
    return new AttachSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachSyncRequest {
    return new AttachSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachSyncRequest {
    return new AttachSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AttachSyncRequest | PlainMessage<AttachSyncRequest> | undefined, b: AttachSyncRequest | PlainMessage<AttachSyncRequest> | undefined): boolean {
    return proto3.util.equals(AttachSyncRequest, a, b);
  }
}

/**
 * Sync contains information about a sync attached to a file.
 *
 * @generated from message file.v1.Sync
 */
export class Sync extends Message<Sync> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string attached_file_id = 2;
   */
  attachedFileId = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 4;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: tenant.v1.UserProfile creator = 5;
   */
  creator?: UserProfile;

  /**
   * @generated from field: file.v1.SyncKind kind = 6;
   */
  kind = SyncKind.UNSPECIFIED;

  /**
   * @generated from field: file.v1.SyncParams params = 7;
   */
  params?: SyncParams;

  constructor(data?: PartialMessage<Sync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.Sync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attached_file_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "updated_at", kind: "message", T: Timestamp },
    { no: 5, name: "creator", kind: "message", T: UserProfile },
    { no: 6, name: "kind", kind: "enum", T: proto3.getEnumType(SyncKind) },
    { no: 7, name: "params", kind: "message", T: SyncParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sync {
    return new Sync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sync {
    return new Sync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sync {
    return new Sync().fromJsonString(jsonString, options);
  }

  static equals(a: Sync | PlainMessage<Sync> | undefined, b: Sync | PlainMessage<Sync> | undefined): boolean {
    return proto3.util.equals(Sync, a, b);
  }
}

/**
 * AttachSyncResponse returns a Sync.
 *
 * @generated from message file.v1.AttachSyncResponse
 */
export class AttachSyncResponse extends Message<AttachSyncResponse> {
  /**
   * @generated from field: file.v1.Sync sync = 1;
   */
  sync?: Sync;

  constructor(data?: PartialMessage<AttachSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.AttachSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: Sync },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachSyncResponse {
    return new AttachSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachSyncResponse {
    return new AttachSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachSyncResponse {
    return new AttachSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AttachSyncResponse | PlainMessage<AttachSyncResponse> | undefined, b: AttachSyncResponse | PlainMessage<AttachSyncResponse> | undefined): boolean {
    return proto3.util.equals(AttachSyncResponse, a, b);
  }
}

/**
 * DeleteSyncRequest deletes a Sync.
 *
 * @generated from message file.v1.DeleteSyncRequest
 */
export class DeleteSyncRequest extends Message<DeleteSyncRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.DeleteSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSyncRequest {
    return new DeleteSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSyncRequest {
    return new DeleteSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSyncRequest {
    return new DeleteSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSyncRequest | PlainMessage<DeleteSyncRequest> | undefined, b: DeleteSyncRequest | PlainMessage<DeleteSyncRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSyncRequest, a, b);
  }
}

/**
 * DeleteSyncResponse is the response to a DeleteSyncRequest.
 *
 * @generated from message file.v1.DeleteSyncResponse
 */
export class DeleteSyncResponse extends Message<DeleteSyncResponse> {
  constructor(data?: PartialMessage<DeleteSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.DeleteSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSyncResponse {
    return new DeleteSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSyncResponse {
    return new DeleteSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSyncResponse {
    return new DeleteSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSyncResponse | PlainMessage<DeleteSyncResponse> | undefined, b: DeleteSyncResponse | PlainMessage<DeleteSyncResponse> | undefined): boolean {
    return proto3.util.equals(DeleteSyncResponse, a, b);
  }
}

/**
 * TextArray is a repeated string.
 *
 * @generated from message file.v1.TextArray
 */
export class TextArray extends Message<TextArray> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<TextArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.TextArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextArray {
    return new TextArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextArray {
    return new TextArray().fromJsonString(jsonString, options);
  }

  static equals(a: TextArray | PlainMessage<TextArray> | undefined, b: TextArray | PlainMessage<TextArray> | undefined): boolean {
    return proto3.util.equals(TextArray, a, b);
  }
}

/**
 * NumberArray is a repeated double.
 *
 * @generated from message file.v1.NumberArray
 */
export class NumberArray extends Message<NumberArray> {
  /**
   * @generated from field: repeated double values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<NumberArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.NumberArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumberArray {
    return new NumberArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumberArray {
    return new NumberArray().fromJsonString(jsonString, options);
  }

  static equals(a: NumberArray | PlainMessage<NumberArray> | undefined, b: NumberArray | PlainMessage<NumberArray> | undefined): boolean {
    return proto3.util.equals(NumberArray, a, b);
  }
}

/**
 * Property is an arbitrary key-value pair attached to a file.
 * Files inherit properties from their parents, and can override
 * inherited properties if needed.
 *
 * @generated from message file.v1.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from oneof file.v1.Property.value
   */
  value: {
    /**
     * @generated from field: string text = 2;
     */
    value: string;
    case: "text";
  } | {
    /**
     * @generated from field: double number = 3;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: file.v1.TextArray text_array = 4;
     */
    value: TextArray;
    case: "textArray";
  } | {
    /**
     * @generated from field: file.v1.NumberArray number_array = 5;
     */
    value: NumberArray;
    case: "numberArray";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 4, name: "text_array", kind: "message", T: TextArray, oneof: "value" },
    { no: 5, name: "number_array", kind: "message", T: NumberArray, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * Properties is a set of properties.
 *
 * @generated from message file.v1.Properties
 */
export class Properties extends Message<Properties> {
  /**
   * @generated from field: map<string, file.v1.Property> properties = 1;
   */
  properties: { [key: string]: Property } = {};

  constructor(data?: PartialMessage<Properties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.Properties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Property} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Properties {
    return new Properties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJsonString(jsonString, options);
  }

  static equals(a: Properties | PlainMessage<Properties> | undefined, b: Properties | PlainMessage<Properties> | undefined): boolean {
    return proto3.util.equals(Properties, a, b);
  }
}

/**
 * SharedWith contains information about a file shared with another user.
 *
 * @generated from message file.v1.SharedWith
 */
export class SharedWith extends Message<SharedWith> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: file.v1.SharingRole role = 2;
   */
  role = SharingRole.UNSPECIFIED;

  /**
   * @generated from oneof file.v1.SharedWith.tenant
   */
  tenant: {
    /**
     * @generated from field: tenant.v1.UserProfile user = 3;
     */
    value: UserProfile;
    case: "user";
  } | {
    /**
     * @generated from field: tenant.v1.GroupProfile group = 4;
     */
    value: GroupProfile;
    case: "group";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SharedWith>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.SharedWith";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role", kind: "enum", T: proto3.getEnumType(SharingRole) },
    { no: 3, name: "user", kind: "message", T: UserProfile, oneof: "tenant" },
    { no: 4, name: "group", kind: "message", T: GroupProfile, oneof: "tenant" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SharedWith {
    return new SharedWith().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SharedWith {
    return new SharedWith().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SharedWith {
    return new SharedWith().fromJsonString(jsonString, options);
  }

  static equals(a: SharedWith | PlainMessage<SharedWith> | undefined, b: SharedWith | PlainMessage<SharedWith> | undefined): boolean {
    return proto3.util.equals(SharedWith, a, b);
  }
}

/**
 * File is the core data structure for files, and can represent
 * both a traditional file as well as a directory. Directories are
 * null-sized files (i.e. size_bytes not set).
 *
 * @generated from message file.v1.File
 */
export class File extends Message<File> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: optional string parent_id = 2;
   */
  parentId?: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 4;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_accessed_at = 5;
   */
  lastAccessedAt?: Timestamp;

  /**
   * @generated from field: file.v1.IndexingStatus indexing_status = 6;
   */
  indexingStatus = IndexingStatus.UNSPECIFIED;

  /**
   * @generated from field: tenant.v1.UserProfile creator = 7;
   */
  creator?: UserProfile;

  /**
   * @generated from field: file.v1.SharingRole role = 8;
   */
  role = SharingRole.UNSPECIFIED;

  /**
   * @generated from field: optional int64 size_bytes = 9;
   */
  sizeBytes?: bigint;

  /**
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * If folder, returns a zip file.
   *
   * @generated from field: string download_url = 11;
   */
  downloadUrl = "";

  /**
   * @generated from field: file.v1.Properties properties = 12;
   */
  properties?: Properties;

  /**
   * Only populated if requested via GetFileRequest.
   *
   * @generated from field: repeated file.v1.File parents = 13;
   */
  parents: File[] = [];

  /**
   * Only populated if file is a folder and you're the owner.
   *
   * @generated from field: repeated file.v1.SharedWith shared_with = 14;
   */
  sharedWith: SharedWith[] = [];

  /**
   * Only populated if file has attached Sync.
   *
   * @generated from field: optional file.v1.Sync sync = 15;
   */
  sync?: Sync;

  /**
   * @generated from field: bool favorite = 16;
   */
  favorite = false;

  constructor(data?: PartialMessage<File>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "file.v1.File";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "updated_at", kind: "message", T: Timestamp },
    { no: 5, name: "last_accessed_at", kind: "message", T: Timestamp },
    { no: 6, name: "indexing_status", kind: "enum", T: proto3.getEnumType(IndexingStatus) },
    { no: 7, name: "creator", kind: "message", T: UserProfile },
    { no: 8, name: "role", kind: "enum", T: proto3.getEnumType(SharingRole) },
    { no: 9, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "download_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "properties", kind: "message", T: Properties },
    { no: 13, name: "parents", kind: "message", T: File, repeated: true },
    { no: 14, name: "shared_with", kind: "message", T: SharedWith, repeated: true },
    { no: 15, name: "sync", kind: "message", T: Sync, opt: true },
    { no: 16, name: "favorite", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): File {
    return new File().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): File {
    return new File().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): File {
    return new File().fromJsonString(jsonString, options);
  }

  static equals(a: File | PlainMessage<File> | undefined, b: File | PlainMessage<File> | undefined): boolean {
    return proto3.util.equals(File, a, b);
  }
}

